var documenterSearchIndex = {"docs":
[{"location":"tests/#Tests","page":"Tests","title":"Tests","text":"","category":"section"},{"location":"tests/","page":"Tests","title":"Tests","text":"Modules = [GeometricEquations.Tests.ExponentialGrowth]","category":"page"},{"location":"tests/#GeometricEquations.Tests.ExponentialGrowth","page":"Tests","title":"GeometricEquations.Tests.ExponentialGrowth","text":"Exponential Growth\n\n\n\n\n\n","category":"module"},{"location":"tests/","page":"Tests","title":"Tests","text":"Modules = [GeometricEquations.Tests.HarmonicOscillator]","category":"page"},{"location":"tests/#GeometricEquations.Tests.HarmonicOscillator","page":"Tests","title":"GeometricEquations.Tests.HarmonicOscillator","text":"Harmonic Oscillator\n\n\n\n\n\n","category":"module"},{"location":"equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"GeometricEquations.GeometricEquation","category":"page"},{"location":"equations/#GeometricEquations.GeometricEquation","page":"Equations","title":"GeometricEquations.GeometricEquation","text":"GeometricEquation{invType,parType,perType} is the abstract type all equation types are derived from.\n\nAll equations should have fields for defining invariants, parameters and periodicity of the main state variable. The types of these fields are stored in the following type parameters:\n\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nThe Optional* types are all unions of the respective Null* types and NamedTuple or AbstractArray, i.e.,\n\nconst OptionalInvariants = Union{NamedTuple, NullInvariants}\nconst OptionalParameters = Union{NamedTuple, NullParameters}\nconst OptionalPeriodicity = Union{AbstractArray, NullPeriodicity}\n\nThe Null* types are empty structs, merely used for dispatch and the traits hasinvariants, hasparameters and hasperiodicity.\n\n\n\n\n\n","category":"type"},{"location":"equations/#Ordinary-Differential-Equations","page":"Equations","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"GeometricEquations.ODE\nGeometricEquations.PODE\nGeometricEquations.HODE\nGeometricEquations.IODE\nGeometricEquations.LODE\nGeometricEquations.SODE","category":"page"},{"location":"equations/#GeometricEquations.ODE","page":"Equations","title":"GeometricEquations.ODE","text":"ODE: Ordinary Differential Equation\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nODE(v, invariants, parameters, periodicity)\nODE(v; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\n    function v(v, t, q, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.PODE","page":"Equations","title":"GeometricEquations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPODE(v, f, invariants, parameters, periodicity)\nPODE(v, f; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\n    function v(v, t, q, p, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, p, params)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.HODE","page":"Equations","title":"GeometricEquations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHODE(v, f, hamiltonian, invariants, parameters, periodicity)\nHODE(v, f, hamiltonian; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\n    function v(v, t, q, p, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f(f, t, q, p, params)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\n    function hamiltonian(t, q, p, params)\n        return ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.IODE","page":"Equations","title":"GeometricEquations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith force field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nλ(t_0) = λ_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\ngType <: Callable: type of g\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (tqv) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIODE(ϑ, f, g, v̄, f̄, invariants, parameters, periodicity)\nIODE(ϑ, f, g; v̄ = _iode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_iode_default_v̄(v, t, q, params) = nothing\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(p, t, q, v)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\n    function g(g, t, q, v, λ)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(v, t, q)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.LODE","page":"Equations","title":"GeometricEquations.LODE","text":"LODE: Lagrangian Ordinary Differential Equation\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the solution (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d. This is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nλ(t_0) = λ_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIODE(ϑ, f, g, ω, l, v̄, f̄, invariants, parameters, periodicity)\nIODE(ϑ, f, g, ω, l; v̄ = _lode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_lode_default_v̄(v, t, q, params) = nothing\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(p, t, q, v)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(g, t, q, λ)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(v, t, q, p)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.SODE","page":"Equations","title":"GeometricEquations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nParameters\n\nvType <: Union{Tuple,Nothing}: type of v\nqType <: Union{Tuple,Nothing}: type of q\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields for each substep\nq: tuple of functions computing the solutions for each substep\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSODE(v, invariants, parameters, periodicity)\nSODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\nSODE(v, q, invariants, parameters, periodicity)\nSODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\n    function v_i(v, t, q, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand the functions q_i providing the solutions must have the interface\n\n    function q_i(q₁, t₁, q₀, t₀, params)\n        q₁[1] = q₀[1] + ...\n        q₁[2] = q₀[2] + ...\n        ...\n    end\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"equations/#Differential-Algebraic-Equations","page":"Equations","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"GeometricEquations.DAE\nGeometricEquations.PDAE\nGeometricEquations.HDAE\nGeometricEquations.IDAE\nGeometricEquations.LDAE\nGeometricEquations.SPDAE","category":"page"},{"location":"equations/#GeometricEquations.DAE","page":"Equations","title":"GeometricEquations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nParameters\n\nvType <: Callable: type of v\nuType <: Callable: type of u\nϕType <: Callable: type of ϕ\nūType <: OptionalCallable: type of ū\nψType <: OptionalCallable: type of ψ\nv̄Type <: Callable: type of v̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v(v, t, q, params)\nu: function computing the projection u(u, t, q, λ, params)\nϕ: algebraic constraint ϕ(ϕ, t, q, params)\nū: function computing the secondary projection field ū(ū, t, q, λ, params) (optional)\nψ: secondary constraint ψ(ψ, t, q, v, params) (optional)\nv̄: function computing an initial guess for the velocity field v (defaults to v)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nDAE(v, u, ϕ, ū, ψ, v̄, invariants, parameters, periodicity)\nDAE(v, u, ϕ, ū, ψ; kwargs...)\nDAE(v, u, ϕ; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nThe DAE is created by\n\nequ = DAE(v, u, ϕ)\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.PDAE","page":"Equations","title":"GeometricEquations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ; kwargs...)\nPDAE(v, f, u, g, ϕ; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nThe PDAE is created by\n\nequ = PDAE(v, f, u, g, ϕ)\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.HDAE","page":"Equations","title":"GeometricEquations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + barg(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barf(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^m times mathbbR^m.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the projection for q\ng: function computing the primary projection field g\nϕ: primary constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, v̄, f̄, invariants, parameters, periodicity)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h; kwargs...)\nHDAE(v, f, u, g, ϕ, h; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nThe HDAE is created by\n\nequ = HDAE(v, f, u, g, ϕ, h)\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.IDAE","page":"Equations","title":"GeometricEquations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) p(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqp)=0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, the algebraic variable lambda taking values in mathbbR^m, and initial conditions (q_0 p_0) and lambda_0,\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nIDAE(ϑ, f, u, g, ϕ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_idae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.LDAE","page":"Equations","title":"GeometricEquations.LDAE","text":"LDAE: Lagrangian Differential Algebraic Equation\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + lambda(t) \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) lambda(t)) + barg (t q(t) mu(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda mu) taking values in mathbbR^d times mathbbR^m times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nωType <: Callable: type of ω\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nlagType <: Callable: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nf: function computing the vector field\nu: function computing the projection for q, for a degenerate system given by lambda\ng: function computing the projection for p, for a degenerate system given by nabla vartheta (q) cdot lambda\nϕ: primary constraints, for a degenerate system given by p - vartheta (tq)\nū: function computing the secondary projection field baru, for a degenerate system given by lambda (optional)\nḡ: function computing the secondary projection field barg, for a degenerate system given by lambda cdot nabla vartheta (tq) (optional)\nψ: secondary constraints, for a degenerate system given by dotp - dotq cdot nabla vartheta (tq) (optional)\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, lagrangian, invariants, parameters, periodicity)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nLDAE(ϑ, f, u, g, ϕ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_ldae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(p, t, q, v)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\n    function g(g, t, q, λ)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(v, t, q)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.SPDAE","page":"Equations","title":"GeometricEquations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nϕType <: Callable: type of ϕ\nψType <: Callable: type of ψ\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, t₀, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"equations/#Stochastic-Differential-Equations","page":"Equations","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"GeometricEquations.SDE\nGeometricEquations.PSDE\nGeometricEquations.SPSDE","category":"page"},{"location":"equations/#GeometricEquations.SDE","page":"Equations","title":"GeometricEquations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nBType <: Callable: type of B\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSDE(v, B, invariants, parameters, periodicity)\nSDE(v, B; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.PSDE","page":"Equations","title":"GeometricEquations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nBType <: Callable: type of B\nGType <: Callable: type of G\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPSDE(v, f, B, G, invariants, parameters, periodicity)\nPSDE(v, f, B, G; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.SPSDE","page":"Equations","title":"GeometricEquations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Function: type of v\nf1Type <: Function: type of f1\nf2Type <: Function: type of f2\nBType <: Function: type of B\nG1Type <: Function: type of G1\nG2Type <: Function: type of G2\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPSDE(v, f1, f2, B, G1, G2, invariants, parameters, periodicity)\nSPSDE(v, f1, f2, B, G1, G2; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"problems/#Problems","page":"Problems","title":"Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"GeometricEquations.GeometricProblem","category":"page"},{"location":"problems/#GeometricEquations.GeometricProblem","page":"Problems","title":"GeometricEquations.GeometricProblem","text":"GeometricProblem: stores a GeometricEquation togehter with initial conditions, parameters, time span and time step size.\n\nParameters\n\nST <: GeometricEquation: super type, used for dispatch\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type of state variable\nequType <: GeometricEquation: equation type\nicsType <: paramsType: initial conditions type\nparType <: OptionalParameters: parameters type\n\nFields\n\nequation: reference to the parent equation object holding the vector fields, etc.\ntspan: time span for problem (t₀,t₁)\ntstep: time step to be used in simulation\nics: NamedTuple containing the initial conditions, must contain one field for each state variable\nparameters: either a NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters\n\nSubtypes\n\nThe GeometricProblem type has various subtypes for the different equations types, that are defined e.g. via\n\nconst ODEProblem = GeometricProblem{ODE}\n\nand provide convenience constructors to construct an equation and the corresponding problem in one step, e.g.,\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::State; kwargs...)\n\nAll problem subtypes take the following keyword arguments:\n\ninvariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()\n\nIf not set to their corresponding Null types, the user needs to pass a NamedTuple whose values are\n\nfunctions for invariants,\narbitrary data structures for parameters, \nthe same data structure as the solution for periodicity.\n\nThe latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range (0, max). Support for ranges starting with other values than zero is currently missing but can be added if demand arises.\n\n\n\n\n\n","category":"type"},{"location":"problems/#Ordinary-Differential-Equations","page":"Problems","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"GeometricEquations.ODEProblem\nGeometricEquations.PODEProblem\nGeometricEquations.HODEProblem\nGeometricEquations.IODEProblem\nGeometricEquations.LODEProblem\nGeometricEquations.SODEProblem","category":"page"},{"location":"problems/#GeometricEquations.ODEProblem","page":"Problems","title":"GeometricEquations.ODEProblem","text":"ODEProblem: Ordinary Differential Equation Problem\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d.\n\nConstructors\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::State; kwargs...)\n\nwhere v is the function computing the vector field,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on GeometricProblem subtypes.\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\n    function v(v, t, q, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.PODEProblem","page":"Problems","title":"GeometricEquations.PODEProblem","text":"PODEProblem: Partitioned Ordinary Differential Equation Problem\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))  \np(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d.\n\nConstructors\n\nPODEProblem(v, f, tspan, tstep, ics; kwargs...)\nPODEProblem(v, f, tspan, tstep, q₀::State, p₀::State; kwargs...)\n\nwhere v and f are the function computing the vector fields,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on GeometricProblem subtypes.\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\n    function v(v, t, q, p, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, p, params)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.HODEProblem","page":"Problems","title":"GeometricEquations.HODEProblem","text":"HODEProblem: Hamiltonian Ordinary Differential Equation Problem\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t))   p(t_0) = p_0 \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the dynamical variables (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nConstructors\n\nHODEProblem(v, f, hamiltonian, tspan, tstep, ics; kwargs...)\nHODEProblem(v, f, hamiltonian, tspan, tstep, q₀::State, p₀::State; kwargs...)\n\nwhere v and f are the function computing the vector fields,  hamiltonian returns the value of the Hamiltonian (i.e. the total energy), tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nKeyword arguments:\n\ninvariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\n    function v(v, t, q, p, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f(f, t, q, p, params)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\n    function hamiltonian(t, q, p, params)\n        return ...\n    end\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.IODEProblem","page":"Problems","title":"GeometricEquations.IODEProblem","text":"IODEProblem: Implicit Ordinary Differential Equation Problem\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith force field f, the momentum defined by p, initial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nλ(t_0) = λ_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nConstructors\n\nIODEProblem(ϑ, f, g, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, an IODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _iode_default_v̄ and f̄ = f.\n\nThe function g should really be optional as it is not required for all but only for most integrators, but for the time being it is required.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(p, t, q, v)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\n    function g(g, t, q, v, λ)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(v, t, q)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.LODEProblem","page":"Problems","title":"GeometricEquations.LODEProblem","text":"LODEProblem: Lagrangian Ordinary Differential Equation Problem\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))\nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the solution (qp) taking values in T^* Q simeq mathbbR^d times mathbbR^d. This is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \nλ(t_0) = λ_0\nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nConstructors\n\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nwhere ϑ, f and g are the functions computing the momentum and the vector fields, respectively, ω determines the symplectic matrix, and l returns the Lagrangian, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}, where λ₀ can also be omitted.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, a LODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _lode_default_v̄ and f̄ = f.\n\nThe function g should really be optional as it is not required for all but only for most integrators, but for the time being it is required.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(p, t, q, v)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g and v are specified by\n\n    function g(g, t, q, λ)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\nand\n\n    function v(v, t, q, p)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.SODEProblem","page":"Problems","title":"GeometricEquations.SODEProblem","text":"SODEProblem: Split Ordinary Differential Equation Problem\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nConstructors\n\nSODEProblem(v, q, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, q, tspan, tstep, q₀::State; kwargs...)\nSODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, tspan, tstep, q₀::State; kwargs...)\n\nwhere v is a tuple of functions computing the vector fields for each substep,  q is an optional tuple of functions computing the solution for each substep, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on GeometricProblem subtypes.\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\n    function v_i(v, t, q, params)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\nand the functions q_i providing the solutions must have the interface\n\n    function q_i(q₁, t₁, q₀, t₀, params)\n        q₁[1] = q₀[1] + ...\n        q₁[2] = q₀[2] + ...\n        ...\n    end\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"problems/#Differential-Algebraic-Equations","page":"Problems","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"GeometricEquations.DAEProblem\nGeometricEquations.PDAEProblem\nGeometricEquations.HDAEProblem\nGeometricEquations.IDAEProblem\nGeometricEquations.LDAEProblem","category":"page"},{"location":"problems/#GeometricEquations.DAEProblem","page":"Problems","title":"GeometricEquations.DAEProblem","text":"DAEProblem: Differential Algebraic Equation Problem\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))   q(t_0) = q_0  \n0 = phi (t q(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0, initial conditions q_0 and lambda_0, the dynamical variable q taking values in mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nConstructors\n\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀::State, λ₀::State; kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, q₀::State, λ₀::State; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and λ. The initial conditions q₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, a DAEProblem accepts a function v̄ for the computation of an initial guess for the vector field with default value v̄ = v.\n\nFunction Definitions\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nWith the above function definitions the DAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\n\nprob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.PDAEProblem","page":"Problems","title":"GeometricEquations.PDAEProblem","text":"PDAEProblem: Partitioned Differential Algebraic Equation Problem\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t) lambda(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0, conditions (q_0 p_0) and lambda_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variable lambda taking values in mathbbR^m.\n\nConstructors\n\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, a PDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nWith the above function definitions the PDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\n\nprob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.HDAEProblem","page":"Problems","title":"GeometricEquations.HDAEProblem","text":"HDAEProblem: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + barg(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barf(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀::State, p₀::State, λ₀::State; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, a HDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nWith the above function definitions the HDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.IDAEProblem","page":"Problems","title":"GeometricEquations.IDAEProblem","text":"IDAEProblem: Implicit Differential Algebraic Equation Problem\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) p(t) lambda(t))   q(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) p(t) lambda(t))   p(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) p(t))   lambda(t_0) = lambda_0 \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqp)=0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, the algebraic variable lambda taking values in mathbbR^m, and initial conditions (q_0 p_0) and lambda_0,\n\nConstructors\n\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, an IDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _idae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.LDAEProblem","page":"Problems","title":"GeometricEquations.LDAEProblem","text":"LDAEProblem: Lagrangian Differential Algebraic Equation Problem\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + lambda(t) \nq(t_0) = q_0  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) lambda(t)) + barg (t q(t) mu(t))  \np(t_0) = p_0  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\ninitial conditions (q_0 p_0) and the solution (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (v lambda mu) taking values in mathbbR^d times mathbbR^m times mathbbR^m. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nConstructors\n\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀::State, p₀::State, λ₀::State = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nIn addition to the standard keyword arguments for GeometricProblem subtypes, a LDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _ldae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\n    function ϑ(p, t, q, v)\n        p[1] = ...\n        p[2] = ...\n        ...\n    end\n\nand\n\n    function f(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\n    function g(g, t, q, λ)\n        g[1] = ...\n        g[2] = ...\n        ...\n    end\n\n    function v̄(v, t, q)\n        v[1] = ...\n        v[2] = ...\n        ...\n    end\n\n    function f̄(f, t, q, v)\n        f[1] = ...\n        f[2] = ...\n        ...\n    end\n\n\n\n\n\n","category":"type"},{"location":"problems/#Stochastic-Differential-Equations","page":"Problems","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"GeometricEquations.SDEProblem\nGeometricEquations.PSDEProblem\nGeometricEquations.SPSDEProblem","category":"page"},{"location":"problems/#GeometricEquations.SDEProblem","page":"Problems","title":"GeometricEquations.SDEProblem","text":"SDEProblem: Stratonovich Stochastic Differential Equation Problem\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSDEProblem(v, B, tspan, tstep, ics::NamedTuple; kwargs...)\nSDEProblem(v, B, tspan, tstep, q₀::State; kwargs...)\n\nwhere v is the function computing the vector field and B computes the diffusion matrix tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on GeometricProblem subtypes.\n\nFunction Definitions\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.PSDEProblem","page":"Problems","title":"GeometricEquations.PSDEProblem","text":"PSDEProblem: Stratonovich Partitioned Stochastic Differential Equation Problem\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nPSDEProblem(v, f, B, G, tspan, tstep, ics::NamedTuple; kwargs...)\nPSDEProblem(v, f, B, G, tspan, tstep, q₀::State; p₀::State; kwargs...)\n\nwhere v and f are the functions computing the vector field and B and G compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on GeometricProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.SPSDEProblem","page":"Problems","title":"GeometricEquations.SPSDEProblem","text":"SPSDEProblem: Stratonovich Split Partitioned Stochastic Differential Equation Problem\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, ics::NamedTuple; kwargs...)\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀::State; p₀::State; kwargs...)\n\nwhere v and f are the functions computing the vector field and Bᵢ and Gᵢ compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with State an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on GeometricProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeometricEquations","category":"page"},{"location":"#GeometricEquations","page":"Home","title":"GeometricEquations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeometricEquations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In GeometricEquations.jl we define three basic types of equations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For each type, there are several subtypes","category":"page"},{"location":"","page":"Home","title":"Home","text":"standard equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\npartitioned equations (PODE, PDAE, PSDE),\nHamiltonian equations (HODE, HDAE),\nLagrangian equations (LODE, LDAE),\nsplit equations (SODE, SPDAE, SPSDE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each equation holds a number of functions determining the vector field, constraints, and possibly additional information like parameters, periodicity, invariants and the Hamiltonian or Lagrangian.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to each equation type, GeometricEquations.jl implements a corresponding problem type. Each problem holds an equation, a time span (t₀,t₁) to integrate over, a time step to be used in the simulation, initial conditions and optionally parameters.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
