<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GeometricEquations.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JuliaGNI.github.io/GeometricEquations.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>GeometricEquations.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Library"><span>Library</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GeometricEquations"><a class="docs-heading-anchor" href="#GeometricEquations">GeometricEquations</a><a id="GeometricEquations-1"></a><a class="docs-heading-anchor-permalink" href="#GeometricEquations" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/JuliaGNI/GeometricEquations.jl">GeometricEquations</a>.</p><p>In <em>GeometricEquations.jl</em> we define three basic types of equations:</p><ul><li>ordinary differential equations (ODEs),</li><li>differential algebraic equations (DAEs),</li><li>stochastic differential equations (SDEs).</li></ul><p>For each type, there are several subtypes</p><ul><li>standard equations (<a href="#GeometricEquations.ODE"><code>ODE</code></a>, <a href="#GeometricEquations.DAE"><code>DAE</code></a>, <a href="#GeometricEquations.SDE"><code>SDE</code></a>),</li><li>implicit equations (<a href="#GeometricEquations.IODE"><code>IODE</code></a>, <a href="#GeometricEquations.IDAE"><code>IDAE</code></a>),</li><li>partitioned equations (<a href="#GeometricEquations.PODE"><code>PODE</code></a>, <a href="#GeometricEquations.PDAE"><code>PDAE</code></a>, <a href="#GeometricEquations.PSDE"><code>PSDE</code></a>),</li><li>Hamiltonian equations (<a href="#GeometricEquations.HODE"><code>HODE</code></a>, <a href="#GeometricEquations.HDAE"><code>HDAE</code></a>),</li><li>Lagrangian equations (<a href="#GeometricEquations.LODE"><code>LODE</code></a>, <a href="#GeometricEquations.LDAE"><code>LDAE</code></a>),</li><li>split equations (<a href="#GeometricEquations.SODE"><code>SODE</code></a>, <a href="#GeometricEquations.SPDAE"><code>SPDAE</code></a>), <a href="#GeometricEquations.SPSDE"><code>SPSDE</code></a>).</li></ul><p>Each equation holds a number of functions determining the vector field, constraints, initial conditions, and possibly additional information like parameters, periodicity, invariants and the Hamiltonian or Lagrangian.</p><h2 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h2><ul><li><a href="#GeometricEquations.DAE"><code>GeometricEquations.DAE</code></a></li><li><a href="#GeometricEquations.DAEProblem"><code>GeometricEquations.DAEProblem</code></a></li><li><a href="#GeometricEquations.GeometricProblem"><code>GeometricEquations.GeometricProblem</code></a></li><li><a href="#GeometricEquations.HDAE"><code>GeometricEquations.HDAE</code></a></li><li><a href="#GeometricEquations.HDAEProblem"><code>GeometricEquations.HDAEProblem</code></a></li><li><a href="#GeometricEquations.HODE"><code>GeometricEquations.HODE</code></a></li><li><a href="#GeometricEquations.HODEProblem"><code>GeometricEquations.HODEProblem</code></a></li><li><a href="#GeometricEquations.IDAE"><code>GeometricEquations.IDAE</code></a></li><li><a href="#GeometricEquations.IDAEProblem"><code>GeometricEquations.IDAEProblem</code></a></li><li><a href="#GeometricEquations.IODE"><code>GeometricEquations.IODE</code></a></li><li><a href="#GeometricEquations.IODEProblem"><code>GeometricEquations.IODEProblem</code></a></li><li><a href="#GeometricEquations.LDAE"><code>GeometricEquations.LDAE</code></a></li><li><a href="#GeometricEquations.LDAEProblem"><code>GeometricEquations.LDAEProblem</code></a></li><li><a href="#GeometricEquations.LODE"><code>GeometricEquations.LODE</code></a></li><li><a href="#GeometricEquations.LODEProblem"><code>GeometricEquations.LODEProblem</code></a></li><li><a href="#GeometricEquations.ODE"><code>GeometricEquations.ODE</code></a></li><li><a href="#GeometricEquations.ODEProblem"><code>GeometricEquations.ODEProblem</code></a></li><li><a href="#GeometricEquations.PDAE"><code>GeometricEquations.PDAE</code></a></li><li><a href="#GeometricEquations.PDAEProblem"><code>GeometricEquations.PDAEProblem</code></a></li><li><a href="#GeometricEquations.PODE"><code>GeometricEquations.PODE</code></a></li><li><a href="#GeometricEquations.PODEProblem"><code>GeometricEquations.PODEProblem</code></a></li><li><a href="#GeometricEquations.PSDE"><code>GeometricEquations.PSDE</code></a></li><li><a href="#GeometricEquations.PSDEProblem"><code>GeometricEquations.PSDEProblem</code></a></li><li><a href="#GeometricEquations.SDE"><code>GeometricEquations.SDE</code></a></li><li><a href="#GeometricEquations.SDEProblem"><code>GeometricEquations.SDEProblem</code></a></li><li><a href="#GeometricEquations.SODE"><code>GeometricEquations.SODE</code></a></li><li><a href="#GeometricEquations.SODEProblem"><code>GeometricEquations.SODEProblem</code></a></li><li><a href="#GeometricEquations.SPDAE"><code>GeometricEquations.SPDAE</code></a></li><li><a href="#GeometricEquations.SPDAEProblem"><code>GeometricEquations.SPDAEProblem</code></a></li><li><a href="#GeometricEquations.SPSDE"><code>GeometricEquations.SPSDE</code></a></li><li><a href="#GeometricEquations.SPSDEProblem"><code>GeometricEquations.SPSDEProblem</code></a></li><li><a href="#GeometricBase.equation-Tuple{AbstractProblem}"><code>GeometricBase.equation</code></a></li><li><a href="#GeometricBase.functions-Tuple{AbstractProblem}"><code>GeometricBase.functions</code></a></li><li><a href="#GeometricBase.invariants-Tuple{AbstractProblem}"><code>GeometricBase.invariants</code></a></li><li><a href="#GeometricBase.solutions-Tuple{AbstractProblem}"><code>GeometricBase.solutions</code></a></li><li><a href="#GeometricEquations.promote_tspan-Union{Tuple{Tuple{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>GeometricEquations.promote_tspan</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.DAE" href="#GeometricEquations.DAE"><code>GeometricEquations.DAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DAE</code>: Differential Algebraic Equation</p><p>Defines a differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t)) + u(t, q(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
0 &amp;= \phi (t, q(t), \lambda(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with vector field <span>$v$</span>, projection <span>$u$</span>, algebraic constraint <span>$\phi=0$</span>, initial conditions <span>$q_{0}$</span> and <span>$\lambda_{0}$</span>, the dynamical variable <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span> and the algebraic variable <span>$\lambda$</span> taking values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>uType &lt;: Function</code>: type of <code>u</code></li><li><code>ūType &lt;: OptionalFunction</code>: type of <code>ū</code></li><li><code>ϕType &lt;: Function</code>: type of <code>ϕ</code></li><li><code>ψType &lt;: OptionalFunction</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variable <span>$q$</span> and the vector field <span>$v$</span></li><li><code>m</code>: dimension of algebraic variable <span>$\lambda$</span> and the constraint <span>$\phi$</span></li><li><code>v</code>: function computing the vector field</li><li><code>u</code>: function computing the projection</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (optional)</li><li><code>ϕ</code>: algebraic constraint</li><li><code>ψ</code>: secondary constraints (optional)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (defaults to <code>v</code>)</li><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span></li><li><code>λ₀</code>: initial condition for algebraic variable <span>$\lambda$</span></li><li><code>μ₀</code>: initial condition for algebraic variable <span>$μ$</span> (optional)</li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The function <code>v</code>, providing the vector field, takes three arguments, <code>v(t, q, v)</code>, the functions <code>u</code> and <code>ϕ</code>, providing the projection and the algebraic constraint take four arguments, <code>u(t, q, λ, u)</code> and <code>ϕ(t, q, λ, ϕ)</code>, where <code>t</code> is the current time, <code>q</code> and <code>λ</code> are the current solution vectors, and <code>v</code>, <code>u</code> and <code>ϕ</code> are the vectors which hold the result of evaluating the vector field <span>$v$</span>, the projection <span>$u$</span> and the algebraic constraint <span>$\phi$</span> on <code>t</code>, <code>q</code> and <code>λ</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">DAE(v, u, ū, ϕ, ψ, v̄, t₀, q₀, λ₀, invariants, parameters, periodicity)

DAE(v, u, ϕ, t₀, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
DAE(v, u, ϕ, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
DAE(v, u, ϕ, t₀, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
DAE(v, u, ϕ, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)

DAE(v, u, ū, ϕ, ψ, t₀, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
DAE(v, u, ū, ϕ, ψ, q₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
DAE(v, u, ū, ϕ, ψ, t₀, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
DAE(v, u, ū, ϕ, ψ, q₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">    function v(t, q, v)
        v[1] = q[1]
        v[2] = q[2]
    end

    function u(t, q, λ, u)
        u[1] = +λ[1]
        u[2] = -λ[1]
    end

    function ϕ(t, q, λ, ϕ)
        ϕ[1] = q[2] - q[1]
    end

    t₀ = 0.
    q₀ = [1., 1.]
    λ₀ = [0.]

    dae = DAE(v, u, ϕ, t₀, q₀, λ₀)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/dae.jl#L1-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.DAEProblem" href="#GeometricEquations.DAEProblem"><code>GeometricEquations.DAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DAEProblem</code>: Differential Algebraic Equation Problem</p><p>Defines a differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t)) + u(t, q(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
0 &amp;= \phi (t, q(t), \lambda(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with vector field <span>$v$</span>, projection <span>$u$</span>, algebraic constraint <span>$\phi=0$</span>, and initial conditions <span>$q_{0}$</span> and <span>$\lambda_{0}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L393-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.GeometricProblem" href="#GeometricEquations.GeometricProblem"><code>GeometricEquations.GeometricProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p>GeometricProblem: stores a GeometricEquation togehter with initial conditions, parameters, time span and time step size.</p><p><strong>Parameters</strong></p><ul><li><code>ST &lt;: GeometricEquation</code>: super type, used for dispatch</li><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>equType &lt;: GeometricEquation</code>: equation type</li><li><code>icsType &lt;: paramsType</code>: initial conditions type</li><li><code>parType &lt;: OptionalParameters</code>: parameters type</li></ul><p><strong>Fields</strong></p><ul><li><code>equation</code>: reference to the parent equation object</li><li><code>tspan</code>: time span for problem <code>(t₀,t₁)</code></li><li><code>tstep</code>: time step to be used in simulation</li><li><code>ics</code>: <code>NamedTuple</code> containing the initial conditions</li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li></ul><p><strong>Subtypes</strong></p><p>The <code>GeometricProblem</code> type has various subtypes for the different equations types, that are defined e.g. via</p><pre><code class="nohighlight hljs">const ODEProblem = GeometricProblem{ODE}</code></pre><p>and provide convenience constructors to construct and equation and the corresponding problem in one step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.HDAE" href="#GeometricEquations.HDAE"><code>GeometricEquations.HDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HDAE</code>: Hamiltonian Differential Algebraic Equation</p><p>Defines a Hamiltonian differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) + \bar{g}(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) + \bar{f}(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span>, <span>$u$</span>, <span>$\bar{u}$</span> and <span>$f$</span>, <span>$g$</span>, <span>$\bar{g}$</span>, primary constraint <span>$\phi(q,p)=0$</span> and secondary constraint <span>$\psi(q,p,\lambda)=0$</span>, initial conditions <span>$(q_{0}, p_{0})$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variables <span>$(\lambda, \gamma)$</span> taking values in <span>$\mathbb{R}^{m} \times \mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>uType &lt;: Function</code>: type of <code>u</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>ϕType &lt;: Function</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Function</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Function</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Function</code>: type of <code>ψ</code></li><li><code>PType &lt;: Function</code>: type of <code>P</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>hamType &lt;: Function</code>: Hamiltonian type</li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$v$</span> and <span>$f$</span></li><li><code>m</code>: dimension of algebraic variables <span>$\lambda$</span> and <span>$\gamma$</span> and the constraints <span>$\phi$</span> and <span>$\psi$</span></li><li><code>v</code>: function computing the Hamiltonian vector field <span>$v$</span></li><li><code>f</code>: function computing the Hamiltonian vector field <span>$f$</span></li><li><code>u</code>: function computing the projection for <span>$q$</span></li><li><code>g</code>: function computing the primary projection field <span>$g$</span></li><li><code>ϕ</code>: primary constraints</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (optional)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span> (optional)</li><li><code>ψ</code>: secondary constraints (optional)</li><li><code>P</code>: function computing the Poisson matrix <span>$P$</span></li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span><code>(optional, defaults to</code>v`)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional, defaults to <code>f</code>)</li><li><code>t₀</code>: initial time (optional)</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span></li><li><code>p₀</code>: initial condition for dynamical variable <span>$p$</span></li><li><code>λ₀</code>: initial condition for algebraic variable <span>$λ$</span></li><li><code>μ₀</code>: initial condition for algebraic variable <span>$μ$</span> (optional)</li><li><code>hamiltonian</code>: function computing the Hamiltonian <span>$H$</span></li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, P, t₀, q₀, p₀, λ₀, hamiltonian, invariants, parameters, periodicity)

HDAE(v, f, u, g, ϕ, h, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
HDAE(v, f, u, g, ϕ, h, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
HDAE(v, f, u, g, ϕ, h, t₀, q₀::State, p₀::State, λ₀::State; kwargs...)
HDAE(v, f, u, g, ϕ, h, q₀::State, p₀::State, λ₀::State; kwargs...)

HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, t₀, q₀::State, p₀::State, λ₀::State; kwargs...)
HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, q₀::State, p₀::State, λ₀::State; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/hdae.jl#L1-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.HDAEProblem" href="#GeometricEquations.HDAEProblem"><code>GeometricEquations.HDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HDAE</code>: Hamiltonian Differential Algebraic Equation</p><p>Defines a Hamiltonian differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) + \bar{g}(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) + \bar{f}(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span>, <span>$u$</span>, <span>$\bar{u}$</span> and <span>$f$</span>, <span>$g$</span>, <span>$\bar{g}$</span>, primary constraint <span>$\phi(q,p)=0$</span> and secondary constraint <span>$\psi(q,p,\lambda)=0$</span>, and initial conditions <span>$(q_{0}, p_{0})$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L469-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.HODE" href="#GeometricEquations.HODE"><code>GeometricEquations.HODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HODE</code>: Hamiltonian Ordinary Differential Equation</p><p>Defines a Hamiltonian ordinary differential initial value problem, that is a canonical Hamiltonian system of equations,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) , &amp; p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
v &amp;=   \frac{\partial H}{\partial p} , &amp;
f &amp;= - \frac{\partial H}{\partial q} ,
\end{aligned}\]</p><p>initial conditions <span>$(q_{0}, p_{0})$</span> and the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>PType &lt;: Function</code>: type of <code>P</code></li><li><code>hamType &lt;: Function</code>: Hamiltonian type</li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$v$</span> and <span>$f$</span></li><li><code>v</code>: function computing the vector field <span>$v$</span></li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>poisson</code>: function computing the Poisson matrix <span>$P$</span></li><li><code>hamiltonian</code>: function computing the Hamiltonian <span>$H$</span></li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HODE(v, f, poisson, t₀, q₀, p₀, hamiltonian, invariants, parameters, periodicity)

HODE(v, f, h, t₀, q₀::StateVector, p₀::StateVector; kwargs...)
HODE(v, f, h, q₀::StateVector, p₀::StateVector; kwargs...)
HODE(v, f, h, t₀, q₀::State, p₀::State; kwargs...)
HODE(v, f, h, q₀::State, p₀::State; kwargs...)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>poisson = symplectic_matrix</code></li><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/hode.jl#L1-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.HODEProblem" href="#GeometricEquations.HODEProblem"><code>GeometricEquations.HODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>HODEProblem</code>: Hamiltonian Ordinary Differential Equation Problem</p><p>Defines a Hamiltonian ordinary differential initial value problem, that is a canonical Hamiltonian system of equations,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) , &amp; p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
v &amp;=   \frac{\partial H}{\partial p} , &amp;
f &amp;= - \frac{\partial H}{\partial q} ,
\end{aligned}\]</p><p>initial conditions <span>$(q_{0}, p_{0})$</span> and the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">HODEProblem(v, f, poisson, hamiltonian, tspan, tstep, ics; kwargs...)
HODEProblem(v, f, poisson, hamiltonian, tspan, tstep, q₀::State, p₀::State; kwargs...)</code></pre><p>where <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code> and <code>p</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>invariants = NullInvariants()</code></li><li><code>parameters = NullParameters()</code></li><li><code>periodicity = NullPeriodicity()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L182-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.IDAE" href="#GeometricEquations.IDAE"><code>GeometricEquations.IDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IDAE</code>: Implicit Differential Algebraic Equation</p><p>Defines an implicit differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), p(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), p(t), \lambda(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= p(t, q(t), v(t)) , &amp;&amp; \\
0 &amp;= \phi (t, q(t), p(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$p$</span>, projection <span>$g$</span> and <span>$r$</span>, algebraic constraint <span>$\phi=0$</span>, conditions <span>$(q_{0}, p_{0})$</span> and <span>$\lambda_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variable <span>$\lambda$</span> taking values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>ϑType &lt;: Function</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>uType &lt;: Function</code>: type of <code>u</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>ϕType &lt;: Function</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Function</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Function</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Function</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$f$</span> and <span>$p$</span></li><li><code>m</code>: dimension of algebraic variable <span>$\lambda$</span> and the constraint <span>$\phi$</span></li><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>u</code>: function computing the projection for <span>$q$</span></li><li><code>g</code>: function computing the projection for <span>$p$</span></li><li><code>ϕ</code>: algebraic constraints</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (optional)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span> (optional)</li><li><code>ψ</code>: secondary constraints (optional)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>t₀</code>: initial time (optional)</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span></li><li><code>p₀</code>: initial condition for dynamical variable <span>$p$</span></li><li><code>λ₀</code>: initial condition for algebraic variable <code>λ</code></li><li><code>μ₀</code>: initial condition for algebraic variable <code>μ</code> (optional)</li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, t₀, q₀, p₀, λ₀, μ₀, invariants, parameters, periodicity)

IDAE(ϑ, f, u, g, ϕ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
IDAE(ϑ, f, u, g, ϕ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
IDAE(ϑ, f, u, g, ϕ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
IDAE(ϑ, f, u, g, ϕ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)

IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
IDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>v̄ = (t,q,v) -&gt; nothing</code></li><li><code>f̄ = f</code></li><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/idae.jl#L1-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.IDAEProblem" href="#GeometricEquations.IDAEProblem"><code>GeometricEquations.IDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IDAEProblem</code>: Implicit Differential Algebraic Equation Problem</p><p>Defines an implicit differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + u(t, q(t), p(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), p(t), \lambda(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= \vartheta(t, q(t), v(t)) , &amp;&amp; \\
0 &amp;= \phi (t, q(t), p(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$p$</span>, projection <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi=0$</span>, and initial conditions <span>$(q_{0}, p_{0})$</span> and <span>$\lambda_{0}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L510-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.IODE" href="#GeometricEquations.IODE"><code>GeometricEquations.IODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IODE</code>: Implicit Ordinary Differential Equation</p><p>Defines an implicit initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t))
\end{aligned}\]</p><p>with force field <span>$f$</span>, the momentum defined by <span>$p$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>ϑType &lt;: Function</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>hType &lt;: OptionalFunction</code>: type of <code>h</code></li><li><code>pType &lt;: Union{NamedTuple,Nothing}</code>: parameters type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$f$</span> and <span>$p$</span></li><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field</li><li><code>g</code>: function determining the projection, given by <span>$\nabla \vartheta (q) \cdot \lambda$</span></li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>h</code>: function computing the Hamiltonian (optional)</li><li><code>t₀</code>: initial time (optional)</li><li><code>q₀</code>: initial condition for <code>q</code></li><li><code>p₀</code>: initial condition for <code>p</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equations parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">    function ϑ(t, q, v, p)
        p[1] = ...
        p[2] = ...
        ...
    end</code></pre><p>and</p><pre><code class="language-julia hljs">    function f(t, q, v, f)
        f[1] = ...
        f[2] = ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. In addition, the functions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">    function g(t, q, λ, g)
        g[1] = ...
        g[2] = ...
        ...
    end

    function v̄(t, q, v)
        v[1] = ...
        v[2] = ...
        ...
    end

    function f̄(t, q, v, f)
        f[1] = ...
        f[2] = ...
        ...
    end</code></pre><p>The function <code>g</code> is used in projection methods that enforce <span>$p = ϑ(q)$</span>. The functions <code>v̄</code> and <code>f̄</code> are used for initial guesses in nonlinear implicit solvers.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">IODE(ϑ, f, v̄, f̄, t₀, q₀, p₀, λ₀, invariants, parameters, periodicity)

IODE(ϑ, f, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)
IODE(ϑ, f, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)
IODE(ϑ, f, t₀, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)
IODE(ϑ, f, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>v̄ = (t,q,v) -&gt; nothing</code></li><li><code>f̄ = f</code></li><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/iode.jl#L1-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.IODEProblem" href="#GeometricEquations.IODEProblem"><code>GeometricEquations.IODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>IODEProblem</code>: Implicit Ordinary Differential Equation Problem</p><p>Defines an implicit initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t))
\end{aligned}\]</p><p>with momentum defined by <span>$\vartheta$</span>, force field <span>$f$</span>, projection field <span>$g$</span> and initial conditions <span>$(q_{0}, p_{0}, \lambda_{0})$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L233-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.LDAE" href="#GeometricEquations.LDAE"><code>GeometricEquations.LDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LDAE</code>: Lagrangian Differential Algebraic Equation</p><p>Defines a Lagrangian differential algebraic initial value problem, that is a special implicit initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + \lambda(t), &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), \lambda(t)) + \bar{g} (t, q(t), \mu(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector field <span>$f$</span>, the momentum defined by <span>$p$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variables <span>$(v, \lambda, \mu)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{m} \times \mathbb{R}^{m}$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variables <span>$v$</span>, <span>$\lambda$</span> and <span>$\mu$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>ϑType &lt;: Function</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>uType &lt;: Function</code>: type of <code>u</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>ϕType &lt;: Function</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Function</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Function</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Function</code>: type of <code>ψ</code></li><li><code>ωType &lt;: Function</code>: type of <code>ω</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>lagType &lt;: Function</code>: Lagrangian type</li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$f$</span> and <span>$p$</span></li><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field</li><li><code>u</code>: function computing the projection for <span>$q$</span>, for a degenerate system given by <span>$\lambda$</span></li><li><code>g</code>: function computing the projection for <span>$p$</span>, for a degenerate system given by <span>$\nabla \vartheta (q) \cdot \lambda$</span></li><li><code>ϕ</code>: primary constraints, for a degenerate system given by <span>$p - \vartheta (q)$</span></li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span>, for a degenerate system given by <span>$\lambda$</span> (optional)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span>, for a degenerate system given by <span>$\lambda \cdot \nabla \vartheta (q)$</span> (optional)</li><li><code>ψ</code>: secondary constraints, for a degenerate system given by <span>$\dot{p} - \dot{q} \cdot \nabla \vartheta (q)$</span> (optional)</li><li><code>ω</code>: function computing the symplectic matrix</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>t₀</code>: initial time (optional)</li><li><code>q₀</code>: initial condition for dynamical variable <code>q</code></li><li><code>p₀</code>: initial condition for dynamical variable <code>p</code></li><li><code>λ₀</code>: initial condition for algebraic variable <code>λ</code></li><li><code>μ₀</code>: initial condition for algebraic variable <code>μ</code> (optional)</li><li><code>lagrangian</code>: function computing the Lagrangian <span>$L$</span></li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">    function ϑ(t, q, v, p)
        p[1] = ...
        p[2] = ...
        ...
    end</code></pre><p>and</p><pre><code class="language-julia hljs">    function f(t, q, v, f)
        f[1] = ...
        f[2] = ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code>, <code>v̄</code> and <code>f̄</code> are specified by</p><pre><code class="language-julia hljs">    function g(t, q, λ, g)
        g[1] = ...
        g[2] = ...
        ...
    end

    function v̄(t, q, v)
        v[1] = ...
        v[2] = ...
        ...
    end

    function f̄(t, q, v, f)
        f[1] = ...
        f[2] = ...
        ...
    end</code></pre><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, t₀, q₀, p₀, λ₀, μ₀, lagrangian, invariants, parameters, periodicity)

LDAE(ϑ, f, u, g, ϕ, l, ω, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
LDAE(ϑ, f, u, g, ϕ, l, ω, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
LDAE(ϑ, f, u, g, ϕ, l, ω, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
LDAE(ϑ, f, u, g, ϕ, l, ω, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)

LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
LDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, l, ω, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>v̄ = (t,q,v) -&gt; nothing</code></li><li><code>f̄ = f</code></li><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/ldae.jl#L1-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.LDAEProblem" href="#GeometricEquations.LDAEProblem"><code>GeometricEquations.LDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LDAEProblem</code>: Lagrangian Differential Algebraic Equation Problem</p><p>Defines a Lagrangian differential algebraic initial value problem, that is a special implicit initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) + \lambda(t), &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) + g(t, q(t), \lambda(t)) + \bar{g} (t, q(t), \mu(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t)) , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector field <span>$f$</span>, the momentum defined by <span>$p$</span>, and initial conditions <span>$(q_{0}, p_{0}, \lambda_{0})$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variables <span>$v$</span>, <span>$\lambda$</span> and <span>$\mu$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L550-L570">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.LODE" href="#GeometricEquations.LODE"><code>GeometricEquations.LODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LODE</code>: Lagrangian Ordinary Differential Equation</p><p>Defines an implicit initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t))
\end{aligned}\]</p><p>with momentum <span>$p$</span> and force field <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
p &amp;= \frac{\partial L}{\partial v} , &amp;
f &amp;= \frac{\partial L}{\partial q} ,
\end{aligned}\]</p><p>initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>ϑType &lt;: Function</code>: type of <code>ϑ</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>ωType &lt;: Function</code>: type of <code>ω</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>lagType &lt;: Function</code>: Lagrangian type</li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$f$</span> and <span>$p$</span></li><li><code>ϑ</code>: function determining the momentum</li><li><code>f</code>: function computing the vector field</li><li><code>g</code>: function determining the projection, given by <span>$\nabla \vartheta (q) \cdot \lambda$</span></li><li><code>ω</code>: function computing the symplectic matrix</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>t₀</code>: initial time (optional)</li><li><code>q₀</code>: initial condition for <code>q</code></li><li><code>p₀</code>: initial condition for <code>p</code></li><li><code>λ₀</code>: initial condition for <code>λ</code> (optional)</li><li><code>lagrangian</code>: function computing the Lagrangian <span>$L$</span></li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>ϑ</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">    function ϑ(t, q, v, p)
        p[1] = ...
        p[2] = ...
        ...
    end</code></pre><p>and</p><pre><code class="language-julia hljs">    function f(t, q, v, f)
        f[1] = ...
        f[2] = ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the current velocity and <code>f</code> and <code>p</code> are the vectors which hold the result of evaluating the functions <span>$f$</span> and <span>$ϑ$</span> on <code>t</code>, <code>q</code> and <code>v</code>. The funtions <code>g</code> and <code>v</code> are specified by</p><pre><code class="language-julia hljs">    function g(t, q, λ, g)
        g[1] = ...
        g[2] = ...
        ...
    end</code></pre><p>and</p><pre><code class="language-julia hljs">    function v(t, q, p, v)
        v[1] = ...
        v[2] = ...
        ...
    end</code></pre><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">LODE(ϑ, f, ω, v̄, f̄, t₀, q₀, p₀, λ₀, lagrangian, invariants, parameters, periodicity)

LODE(ϑ, f, l, ω, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)
LODE(ϑ, f, l, ω, q₀::StateVector, p₀::StateVector, λ₀::StateVector=zero(q₀); kwargs...)
LODE(ϑ, f, l, ω, t₀, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)
LODE(ϑ, f, l, ω, q₀::State, p₀::State, λ₀::StateVector=zero(q₀); kwargs...)</code></pre><p><strong>Keyword arguments</strong></p><ul><li><code>v̄ = (t,q,v) -&gt; nothing</code></li><li><code>f̄ = f</code></li><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/lode.jl#L1-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.LODEProblem" href="#GeometricEquations.LODEProblem"><code>GeometricEquations.LODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>LODEProblem</code>: Lagrangian Ordinary Differential Equation Problem</p><p>Defines an implicit initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), v(t)) , &amp;
p(t_{0}) &amp;= p_{0} , \\
p(t) &amp;= ϑ(t, q(t), v(t))
\end{aligned}\]</p><p>with momentum <span>$p$</span> and force field <span>$f$</span>, given by</p><p class="math-container">\[\begin{aligned}
p &amp;= \frac{\partial L}{\partial v} , &amp;
f &amp;= \frac{\partial L}{\partial q} ,
\end{aligned}\]</p><p>and initial conditions <span>$(q_{0}, p_{0})$</span>. This is a special case of a differential algebraic equation with dynamical variables <span>$(q,p)$</span> and algebraic variable <span>$v$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L266-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.ODE" href="#GeometricEquations.ODE"><code>GeometricEquations.ODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ODE</code>: Ordinary Differential Equation</p><p>Defines an initial value problem</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span>, initial condition <span>$q_{0}$</span> and the solution <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Callable</code>: type of <code>v</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field</li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p>The function <code>v</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">    function v(t, q, v, params)
        v[1] = ...
        v[2] = ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q</code> is the current solution vector, <code>v</code> is the vector which holds the result of evaluating the vector field <span>$v$</span> on <code>t</code> and <code>q</code>, and params are additional parameters.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ODE(v, invariants, parameters, periodicity)
ODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/ode.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.ODEProblem" href="#GeometricEquations.ODEProblem"><code>GeometricEquations.ODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>ODEProblem</code>: Ordinary Differential Equation Problem</p><p>Defines an initial value problem</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span> and initial condition <span>$q_{0}$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ODE(v, tspan, tstep, ics::NamedTuple; kwargs...)
ODE(v, tspan, tstep, q₀::State; kwargs...)</code></pre><p>where <code>ics</code> is a <code>NamedTuple</code> with entry <code>q</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>invariants = NullInvariants()</code></li><li><code>parameters = NullParameters()</code></li><li><code>periodicity = NullPeriodicity()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L98-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PDAE" href="#GeometricEquations.PDAE"><code>GeometricEquations.PDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PDAE</code>: Partitioned Differential Algebraic Equation</p><p>Defines a partitioned differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t), \lambda(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, projection <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi=0$</span>, conditions <span>$(q_{0}, p_{0})$</span> and <span>$\lambda_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variable <span>$\lambda$</span> taking values in <span>$\mathbb{R}^{m}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>uType &lt;: Function</code>: type of <code>u</code></li><li><code>gType &lt;: Function</code>: type of <code>g</code></li><li><code>ϕType &lt;: Function</code>: type of <code>ϕ</code></li><li><code>ūType &lt;: Function</code>: type of <code>ū</code></li><li><code>ḡType &lt;: Function</code>: type of <code>ḡ</code></li><li><code>ψType &lt;: Function</code>: type of <code>ψ</code></li><li><code>v̄Type &lt;: Function</code>: type of <code>v̄</code></li><li><code>f̄Type &lt;: Function</code>: type of <code>f̄</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$f$</span> and <span>$p$</span></li><li><code>m</code>: dimension of algebraic variable <span>$\lambda$</span> and the constraint <span>$\phi$</span></li><li><code>v</code>: function computing the vector field <span>$v$</span></li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>u</code>: function computing the projection for <span>$q$</span></li><li><code>g</code>: function computing the projection for <span>$p$</span></li><li><code>ϕ</code>: algebraic constraints</li><li><code>ū</code>: function computing the secondary projection field <span>$\bar{u}$</span> (optional)</li><li><code>ḡ</code>: function computing the secondary projection field <span>$\bar{g}$</span> (optional)</li><li><code>ψ</code>: secondary constraints (optional)</li><li><code>v̄</code>: function computing an initial guess for the velocity field <span>$v$</span> (optional)</li><li><code>f̄</code>: function computing an initial guess for the force field <span>$f$</span> (optional)</li><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span></li><li><code>p₀</code>: initial condition for dynamical variable <span>$p$</span></li><li><code>λ₀</code>: initial condition for algebraic variable <span>$\lambda$</span></li><li><code>μ₀</code>: initial condition for algebraic variable <span>$μ$</span> (optional)</li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, t₀, q₀, p₀, λ₀, invariants, parameters, periodicity)

PDAE(v, f, u, g, ϕ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
PDAE(v, f, u, g, ϕ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
PDAE(v, f, u, g, ϕ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
PDAE(v, f, u, g, ϕ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)

PDAE(v, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
PDAE(v, f, u, g, ϕ, ū, ḡ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector, μ₀::StateVector=zero(λ₀); kwargs...)
PDAE(v, f, u, g, ϕ, ū, ḡ, ψ, t₀, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)
PDAE(v, f, u, g, ϕ, ū, ḡ, ψ, q₀::State, p₀::State, λ₀::State, μ₀::State=zero(λ₀); kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/pdae.jl#L1-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PDAEProblem" href="#GeometricEquations.PDAEProblem"><code>GeometricEquations.PDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PDAEProblem</code>: Partitioned Differential Algebraic Equation Problem</p><p>Defines a partitioned differential algebraic initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) + u(t, q(t), p(t), \lambda(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) + g(t, q(t), p(t), \lambda(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t), \lambda(t)) , &amp; \lambda(t_{0}) &amp;= \lambda_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, projection <span>$u$</span> and <span>$g$</span>, algebraic constraint <span>$\phi=0$</span>, and initial conditions <span>$(q_{0}, p_{0})$</span> and <span>$\lambda_{0}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L430-L444">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PODE" href="#GeometricEquations.PODE"><code>GeometricEquations.PODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PODE</code>: Partitioned Ordinary Differential Equation</p><p>Defines a partitioned initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) , &amp;
p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span>, initial conditions <span>$(q_{0}, p_{0})$</span> and the solution <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: function computing the vector field <span>$v$</span></li><li><code>f</code>: function computing the vector field <span>$f$</span></li><li><code>invariants</code>: functions for the computation of invariants, either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>NullInvariants</code></li><li><code>parameters</code>: type constraints for parameters, either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>NullParameters</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions, either a <code>AbstractArray</code> or <code>NullPeriodicity</code></li></ul><p>The functions <code>v</code> and <code>f</code> must have the interface</p><pre><code class="language-julia hljs">    function v(t, q, p, v, params)
        v[1] = ...
        v[2] = ...
        ...
    end</code></pre><p>and</p><pre><code class="language-julia hljs">    function f(t, q, p, f, params)
        f[1] = ...
        f[2] = ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q</code> and <code>p</code> are the current solution vectors, <code>v</code> and <code>f</code> are the vectors which hold the result of evaluating the vector fields <span>$v$</span> and <span>$f$</span> on <code>t</code>, <code>q</code> and <code>p</code>, and params are additional parameters.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PODE(v, f, invariants, parameters, periodicity)
PODE(v, f; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/pode.jl#L1-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PODEProblem" href="#GeometricEquations.PODEProblem"><code>GeometricEquations.PODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PODEProblem</code>: Partitioned Ordinary Differential Equation Problem</p><p>Defines a partitioned initial value problem</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v(t, q(t), p(t)) , &amp;
q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f(t, q(t), p(t)) , &amp;
p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with vector fields <span>$v$</span> and <span>$f$</span> and initial conditions <span>$(q_{0}, p_{0})$</span>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PODE(v, f, tspan, tstep, ics; kwargs...)
PODE(v, f, tspan, tstep, q₀::State, p₀::State; kwargs...)</code></pre><p>where <code>ics</code> is a <code>NamedTuple</code> with entries <code>q</code> and <code>p</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>invariants = NullInvariants()</code></li><li><code>parameters = NullParameters()</code></li><li><code>periodicity = NullPeriodicity()</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L137-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PSDE" href="#GeometricEquations.PSDE"><code>GeometricEquations.PSDE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>PSDE</code>: Stratonovich Partitioned Stochastic Differential Equation</p><p>Defines a partitioned stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;= v(t, q(t)) \, dt + B(t, q(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} , \\
dp (t) &amp;= f(t, q(t)) \, dt + G(t, q(t)) \circ dW , &amp; p(t_{0}) &amp;= p_{0}
\end{aligned}\]</p><p>with the drift vector fields <span>$v$</span> and <span>$f$</span>, diffusion matrices <span>$B$</span> and <span>$G$</span>, initial conditions <span>$q_{0}$</span> and <span>$p_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>BType &lt;: Function</code>: type of <code>B</code></li><li><code>GType &lt;: Function</code>: type of <code>G</code></li><li><code>pType &lt;: Union{NamedTuple,Nothing}</code>: parameters type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>:  dimension of dynamical variable <span>$q$</span> and the vector field <span>$v$</span></li><li><code>m</code>:  dimension of the Wiener process</li><li><code>ns</code>: number of sample paths</li><li><code>v</code>:  function computing the drift vector field for the position variable <span>$q$</span></li><li><code>f</code>:  function computing the drift vector field for the momentum variable <span>$p$</span></li><li><code>B</code>:  function computing the d x m diffusion matrix for the position variable <span>$q$</span></li><li><code>G</code>:  function computing the d x m diffusion matrix for the momentum variable <span>$p$</span></li><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span> (may be a random variable itself)</li><li><code>p₀</code>: initial condition for dynamical variable <span>$p$</span> (may be a random variable itself)</li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equations parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code>, providing the drift vector fields and diffusion matrices, take four arguments, <code>v(t, q, p, v)</code>, <code>f(t, q, p, f)</code>, <code>B(t, q, p,  B)</code> and <code>G(t, q, p, G)</code>, where <code>t</code> is the current time, <code>(q, p)</code> is the current solution vector, and <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code> are the variables which hold the result of evaluating the vector fields <span>$v$</span>, <span>$f$</span> and the matrices <span>$B$</span>, <span>$G$</span> on <code>t</code> and <code>(q,p)</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">PSDE(m, ns, v, f, B, G, t₀, q₀, p₀; parameters=NullParameters(), periodicity=zero(q₀[begin]))
PSDE(m, ns, v, f, B, G, q₀::StateVector, p₀::StateVector; kwargs...) = PSDE(m, ns, v, f, B, G, 0.0, q₀, p₀; kwargs...)
PSDE(m, ns, v, f, B, G, t₀, q₀::State, p₀::State; kwargs...) = PSDE(m, ns, v, f, B, G, t₀, [q₀], [p₀]; kwargs...)
PSDE(m, ns, v, f, B, G, q₀::State, p₀::State; kwargs...) = PSDE(m, ns, v, f, B, G, 0.0, q₀, p₀; kwargs...)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">    function v(λ, t, q, v)
        v[1] = λ*q[1]
        v[2] = λ*q[2]
    end

    function B(μ, t, q, B)
        B[1] = μ*q[1]
        B[2] = μ*q[2]
    end

    t₀ = 0.
    q₀ = [1., 1.]
    λ  = 2.
    μ  = 1.

    v_sde = (t, q, v) -&gt; v(λ, t, q, v)
    B_sde = (t, q, B) -&gt; B(μ, t, q, B)

    sde = SDE(v_sde, B_sde, t₀, q₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/psde.jl#L1-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.PSDEProblem" href="#GeometricEquations.PSDEProblem"><code>GeometricEquations.PSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L609-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SDE" href="#GeometricEquations.SDE"><code>GeometricEquations.SDE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SDE</code>: Stratonovich Stochastic Differential Equation</p><p>Defines a stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;= v(t, q(t)) \, dt + B(t, q(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} ,
\end{aligned}\]</p><p>with drift vector field <span>$v$</span>, diffusion matrix <span>$B$</span>, initial conditions <span>$q_{0}$</span>, the dynamical variable <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>BType &lt;: Function</code>: type of <code>B</code></li><li><code>pType &lt;: Union{NamedTuple,Nothing}</code>: parameters type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>:  dimension of dynamical variable <span>$q$</span> and the vector field <span>$v$</span></li><li><code>m</code>:  dimension of the Wiener process</li><li><code>ns</code>: number of sample paths</li><li><code>v</code>:  function computing the deterministic vector field</li><li><code>B</code>:  function computing the d x m diffusion matrix</li><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span> (may be a random variable itself)</li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equations parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>v</code> and <code>B</code>, providing the drift vector field and diffusion matrix, <code>v(t, q, v)</code> and <code>B(t, q, B, col=0)</code>, where <code>t</code> is the current time, <code>q</code> is the current solution vector, and <code>v</code> and <code>B</code> are the variables which hold the result of evaluating the vector field <span>$v$</span> and the matrix <span>$B$</span> on <code>t</code> and <code>q</code> (if col==0), or the column col of the matrix B (if col&gt;0).</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SDE(m, ns, v, B, t₀, q₀; parameters=NullParameters(), periodicity=zero(q₀[begin]))
SDE(m, ns, v, B, q₀::StateVector; kwargs...) = SDE(m, ns, v, B, 0.0, q₀; kwargs...)
SDE(m, ns, v, B, t₀, q₀::State; kwargs...) = SDE(m, ns, v, B, t₀, [q₀]; kwargs...)
SDE(m, ns, v, B, q₀::State; kwargs...) = SDE(m, ns, v, B, 0.0, q₀; kwargs...)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">    function v(t, q, v, p)
        λ = p[:λ]
        v[1] = λ*q[1]
        v[2] = λ*q[2]
    end

    function B(t, q, B, p, col=0)
        μ = p[:μ]
        if col==0 #whole matrix
            B[1,1] = μ*q[1]
            B[2,1] = μ*q[2]
        elseif col==1
            #just first column
        end
    end

    t₀ = 0.
    q₀ = [1., 1.]
    λ  = 2.
    μ  = 1.
    p = (λ=λ, μ=μ)

    sde = SDE(v, B, t₀, q₀; parameters=p)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/sde.jl#L1-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SDEProblem" href="#GeometricEquations.SDEProblem"><code>GeometricEquations.SDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L603-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SODE" href="#GeometricEquations.SODE"><code>GeometricEquations.SODE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SODE</code>: Split Ordinary Differential Equation</p><p>Defines an initial value problem</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span>, initial condition <span>$q_{0}$</span> and the solution <span>$q$</span> taking values in <span>$\mathbb{R}^{d}$</span>. Here, the vector field <span>$v$</span> is given as a sum of vector fields</p><p class="math-container">\[v (t) = v_1 (t) + ... + v_r (t) .\]</p><p><strong>Parameters</strong></p><ul><li><code>vType &lt;: Union{Tuple,Nothing}</code>: type of <code>v</code></li><li><code>qType &lt;: Union{Tuple,Nothing}</code>: type of <code>q</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>v</code>: tuple of functions computing the vector field</li><li><code>q</code>: tuple of functions computing the solution</li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>v_i</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">    function v_i(t, q, v, params)
        v[1] = ...
        v[2] = ...
        ...
    end</code></pre><p>and the functions <code>q_i</code> providing the solutions must have the interface</p><pre><code class="language-julia hljs">    function q_i(t, q₀, q₁, h, params)
        q₁[1] = q₀[1] + ...
        q₁[2] = q₀[2] + ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q₀</code> is the current solution vector, <code>q₁</code> is the new solution vector which holds the result of computing one substep with the vector field <span>$v_i$</span> on <code>t</code> and <code>q₀</code>, and <code>h</code> is the (sub-)timestep to compute the update for.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SODE(v, invariants, parameters, periodicity)
SODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())
SODE(v, q, invariants, parameters, periodicity)
SODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/sode.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SODEProblem" href="#GeometricEquations.SODEProblem"><code>GeometricEquations.SODEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SODEProblem</code>: Split Ordinary Differential Equation Problem</p><p>Defines an initial value problem</p><p class="math-container">\[\dot{q} (t) = v(t, q(t)) , \qquad q(t_{0}) = q_{0} ,\]</p><p>with vector field <span>$v$</span> and initial condition <span>$q_{0}$</span>. Here, the vector field <span>$v$</span> is given as a sum of vector fields</p><p class="math-container">\[v (t) = v_1 (t) + ... + v_r (t) .\]</p><p><strong>Fields</strong></p><ul><li><code>equation</code>: reference to the parent equation object</li><li><code>functions</code>: all functions (e.g. vector fields) provided by the equation</li><li><code>tspan</code>: time span for problem <code>(t₀,t₁)</code></li><li><code>tstep</code>: time step to be used in simulation</li><li><code>ics</code>: initial condition (NamedTuple containing the field <code>q</code>)</li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li></ul><p>The functions <code>v_i</code> providing the vector field must have the interface</p><pre><code class="language-julia hljs">    function v_i(t, q, v, params)
        v[1] = ...
        v[2] = ...
        ...
    end</code></pre><p>and the functions <code>q_i</code> providing the solutions must have the interface</p><pre><code class="language-julia hljs">    function q_i(t, q₀, q₁, h, params))
        q₁[1] = q₀[1] + ...
        q₁[2] = q₀[2] + ...
        ...
    end</code></pre><p>where <code>t</code> is the current time, <code>q₀</code> is the current solution vector, <code>q₁</code> is the new solution vector which holds the result of computing one substep with the vector field <span>$v_i$</span> on <code>t</code> and <code>q₀</code>, and <code>h</code> is the (sub-)timestep to compute the update for.</p><p>The fact that the function <code>v</code> returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SODE(v, q, t₀, q₀, invariants, parameters, periodicity)

SODE(v, q::Union{Tuple,Nothing}, t₀::Real, q₀::StateVector; kwargs...)
SODE(v, q::Union{Tuple,Nothing}, t₀::Real, q₀::State; kwargs...)
SODE(v, q::Union{Tuple,Nothing}, q₀::StateVector; kwargs...)
SODE(v, q::Union{Tuple,Nothing}, q₀::State; kwargs...)

SODE(v, t₀::Real, q₀::StateVector; kwargs...)
SODE(v, t₀::Real, q₀::State; kwargs...)
SODE(v, q₀::StateVector; kwargs...)
SODE(v, q₀::State; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L305-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SPDAE" href="#GeometricEquations.SPDAE"><code>GeometricEquations.SPDAE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SPDAE</code>: Split Partitioned Differential Algebraic Equation <em>EXPERIMENTAL</em></p><p>Defines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,</p><p class="math-container">\[\begin{aligned}
\dot{q} (t) &amp;= v_1(t, q(t), p(t)) + v_2(t, q(t), p(t), \lambda(t)) + v_3(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; q(t_{0}) &amp;= q_{0} , \\
\dot{p} (t) &amp;= f_1(t, q(t), p(t)) + f_2(t, q(t), p(t), \lambda(t)) + f_3(t, q(t), p(t), \lambda(t), \gamma(t)) , &amp; p(t_{0}) &amp;= p_{0} , \\
0 &amp;= \phi (t, q(t), p(t)) , \\
0 &amp;= \psi (t, q(t), p(t), \dot{q}(t), \dot{p}(t)) ,
\end{aligned}\]</p><p>with vector fields <span>$v_i$</span> and <span>$f_i$</span> for <span>$i = 1 ... 3$</span>, primary constraint <span>$\phi(q,p)=0$</span> and secondary constraint <span>$\psi(q,p,\lambda)=0$</span>, initial conditions <span>$(q_{0}, p_{0})$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span> and the algebraic variables <span>$(\lambda, \gamma)$</span> taking values in <span>$\mathbb{R}^{n} \times \mathbb{R}^{d}$</span>.</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>fType &lt;: Function</code>: type of <code>f</code></li><li><code>ϕType &lt;: Function</code>: type of <code>ϕ</code></li><li><code>ψType &lt;: Function</code>: type of <code>ψ</code></li><li><code>invType &lt;: OptionalNamedTuple</code>: invariants type</li><li><code>parType &lt;: OptionalNamedTuple</code>: parameters type</li><li><code>perType &lt;: OptionalArray{AT}</code>: periodicity type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>: dimension of dynamical variables <span>$q$</span> and <span>$p$</span> as well as the vector fields <span>$v$</span> and <span>$f$</span></li><li><code>m</code>: dimension of algebraic variables <span>$\lambda$</span> and <span>$\gamma$</span> and the constraints <span>$\phi$</span> and <span>$\psi$</span></li><li><code>v</code>: tuple of functions computing the vector fields <span>$v_i$</span>, <span>$i = 1 ... 3$</span></li><li><code>f</code>: tuple of functions computing the vector fields <span>$f_i$</span>, <span>$i = 1 ... 3$</span></li><li><code>ϕ</code>: primary constraints</li><li><code>ψ</code>: secondary constraints</li><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span></li><li><code>p₀</code>: initial condition for dynamical variable <span>$p$</span></li><li><code>λ₀</code>: initial condition for algebraic variable <span>$λ$</span></li><li><code>μ₀</code>: initial condition for algebraic variable <span>$μ$</span> (optional)</li><li><code>invariants</code>: either a <code>NamedTuple</code> containing the equation&#39;s invariants or <code>nothing</code></li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equation&#39;s parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
SPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)
SPDAE(v, f, ϕ, ψ, t₀, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)
SPDAE(v, f, ϕ, ψ, q₀::State, p₀::State, λ₀::State=zero(q₀); kwargs...)</code></pre><p><strong>Keyword arguments:</strong></p><ul><li><code>invariants = nothing</code></li><li><code>parameters = nothing</code></li><li><code>periodicity = nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/spdae.jl#L1-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SPDAEProblem" href="#GeometricEquations.SPDAEProblem"><code>GeometricEquations.SPDAEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L595-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SPSDE" href="#GeometricEquations.SPSDE"><code>GeometricEquations.SPSDE</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>SPSDE</code>: Stratonovich Split Partitioned Stochastic Differential Equation</p><p>Defines a partitioned stochastic differential initial value problem</p><p class="math-container">\[\begin{aligned}
dq (t) &amp;=   v(t, q(t)) \, dt + B(t, q(t)) \circ dW , &amp; q(t_{0}) &amp;= q_{0} , \\
dp (t) &amp;= [ f_1(t, q(t)) + f_2(t, q(t)) ] \, dt + [ G_1(t, q(t)) + G_2(t, q(t)) ] \circ dW , &amp; p(t_{0}) &amp;= p_{0} ,
\end{aligned}\]</p><p>with the drift vector fields <span>$v$</span> and <span>$f_i$</span>, diffusion matrices <span>$B$</span> and <span>$G_i$</span>, initial conditions <span>$q_{0}$</span> and <span>$p_{0}$</span>, the dynamical variables <span>$(q,p)$</span> taking values in <span>$\mathbb{R}^{d} \times \mathbb{R}^{d}$</span>, and the m-dimensional Wiener process W</p><p><strong>Parameters</strong></p><ul><li><code>DT &lt;: Number</code>: data type</li><li><code>TT &lt;: Real</code>: time step type</li><li><code>AT &lt;: AbstractArray{DT}</code>: array type</li><li><code>vType &lt;: Function</code>: type of <code>v</code></li><li><code>f1Type &lt;: Function</code>: type of <code>f1</code></li><li><code>f2Type &lt;: Function</code>: type of <code>f2</code></li><li><code>BType &lt;: Function</code>: type of <code>B</code></li><li><code>G1Type &lt;: Function</code>: type of <code>G1</code></li><li><code>G2Type &lt;: Function</code>: type of <code>G2</code></li><li><code>pType &lt;: Union{NamedTuple,Nothing}</code>: parameters type</li></ul><p><strong>Fields</strong></p><ul><li><code>d</code>:  dimension of dynamical variable <span>$q$</span> and the vector fields <span>$vi$</span></li><li><code>m</code>:  dimension of the Wiener process</li><li><code>ni</code>: number of initial conditions</li><li><code>ns</code>: number of sample paths</li><li><code>v</code> :  function computing the drift vector field for the position variable <span>$q$</span></li><li><code>f1</code>:  function computing the drift vector field for the momentum variable <span>$p$</span></li><li><code>f2</code>:  function computing the drift vector field for the momentum variable <span>$p$</span></li><li><code>B</code> :  function computing the d x m diffusion matrix for the position variable <span>$q$</span></li><li><code>G1</code>:  function computing the d x m diffusion matrix for the momentum variable <span>$p$</span></li><li><code>G2</code>:  function computing the d x m diffusion matrix for the momentum variable <span>$p$</span></li><li><code>t₀</code>: initial time</li><li><code>q₀</code>: initial condition for dynamical variable <span>$q$</span> (may be a random variable itself)</li><li><code>p₀</code>: initial condition for dynamical variable <span>$p$</span> (may be a random variable itself)</li><li><code>parameters</code>: either a <code>NamedTuple</code> containing the equations parameters or <code>nothing</code></li><li><code>periodicity</code>: determines the periodicity of the state vector <code>q</code> for cutting periodic solutions</li></ul><p>The functions <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code>, providing the drift vector fields and diffusion matrices, take four arguments, <code>v(t, q, p, v)</code>, <code>f(t, q, p, f)</code>, <code>B(t, q, p,  B)</code> and <code>G(t, q, p, G)</code>, where <code>t</code> is the current time, <code>(q, p)</code> is the current solution vector, and <code>v</code>, <code>f</code>, <code>B</code> and <code>G</code> are the variables which hold the result of evaluating the vector fields <span>$v$</span>, <span>$f$</span> and the matrices <span>$B$</span>, <span>$G$</span> on <code>t</code> and <code>(q,p)</code>.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SPSDE(m, ns, v, f1, f2, B, G1, G2, t₀, q₀, p₀; parameters=NullParameters(), periodicity=zero(q₀[begin]))
SPSDE(m, ns, v, f1, f2, B, G1, G2, q₀::StateVector, p₀::StateVector; kwargs...) = SPSDE(m, ns, v, f1, f2, B, G1, G2, 0.0, q₀, p₀; kwargs...)
SPSDE(m, ns, v, f1, f2, B, G1, G2, t₀, q₀::State, p₀::State; kwargs...) = SPSDE(m, ns, v, f1, f2, B, G1, G2, t₀, [q₀], [p₀]; kwargs...)
SPSDE(m, ns, v, f1, f2, B, G1, G2, q₀::State, p₀::State; kwargs...) = SPSDE(m, ns, v, f1, f2, B, G1, G2, 0.0, q₀, p₀; kwargs...)</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">    function v(λ, t, q, v)
        v[1] = λ*q[1]
        v[2] = λ*q[2]
    end

    function B(μ, t, q, B)
        B[1] = μ*q[1]
        B[2] = μ*q[2]
    end

    t₀ = 0.
    q₀ = [1., 1.]
    λ  = 2.
    μ  = 1.

    v_sde = (t, q, v) -&gt; v(λ, t, q, v)
    B_sde = (t, q, B) -&gt; B(μ, t, q, B)

    sde = SDE(v_sde, B_sde, t₀, q₀)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/spsde.jl#L1-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.SPSDEProblem" href="#GeometricEquations.SPSDEProblem"><code>GeometricEquations.SPSDEProblem</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/geometric_problem.jl#L615-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricBase.equation-Tuple{AbstractProblem}" href="#GeometricBase.equation-Tuple{AbstractProblem}"><code>GeometricBase.equation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns the parent equation object of the problem.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/abstract_problem.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricBase.functions-Tuple{AbstractProblem}" href="#GeometricBase.functions-Tuple{AbstractProblem}"><code>GeometricBase.functions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a NamedTuple containing all functions (e.g. vector fields) provided by the equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/abstract_problem.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricBase.invariants-Tuple{AbstractProblem}" href="#GeometricBase.invariants-Tuple{AbstractProblem}"><code>GeometricBase.invariants</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a NamedTuple containing all invariants provided by the equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/abstract_problem.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricBase.solutions-Tuple{AbstractProblem}" href="#GeometricBase.solutions-Tuple{AbstractProblem}"><code>GeometricBase.solutions</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Returns a NamedTuple containing all solutions provided by the equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/abstract_problem.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometricEquations.promote_tspan-Union{Tuple{Tuple{T, S}}, Tuple{S}, Tuple{T}} where {T, S}" href="#GeometricEquations.promote_tspan-Union{Tuple{Tuple{T, S}}, Tuple{S}, Tuple{T}} where {T, S}"><code>GeometricEquations.promote_tspan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">promote_tspan(tspan)</code></pre><p>Convert the <code>tspan</code> field of a <code>GeometricProblem</code> to a <code>(tmin, tmax)</code> tuple, where both elements are of the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGNI/GeometricEquations.jl/blob/e271182a6d96854bbf574e08338f63b269a1ef11/src/utils.jl#L6-L10">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 23 September 2022 09:08">Friday 23 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
