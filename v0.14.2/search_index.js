var documenterSearchIndex = {"docs":
[{"location":"ensembles/","page":"Ensembles","title":"Ensembles","text":"CurrentModule = GeometricEquations","category":"page"},{"location":"ensembles/#Ensembles","page":"Ensembles","title":"Ensembles","text":"","category":"section"},{"location":"ensembles/","page":"Ensembles","title":"Ensembles","text":"EnsembleProblem","category":"page"},{"location":"ensembles/#GeometricEquations.EnsembleProblem","page":"Ensembles","title":"GeometricEquations.EnsembleProblem","text":"EnsembleProblem: stores a GeometricEquation together with multiple sets of initial conditions, parameters, time span and time step size.\n\n\n\n\n\n","category":"type"},{"location":"equations/","page":"Equations","title":"Equations","text":"CurrentModule = GeometricEquations","category":"page"},{"location":"equations/#Equations","page":"Equations","title":"Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"Equations hold a number of functions determining vector fields, constraints, invariants, the Hamiltonian or Lagrangian and the symplectic structure.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"There exists a hierarchy of abstract data types. At the top stands the GeometricEquation type. From that several types derive for ODEs, DAEs, SDEs and their partitioned counterparts:","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"AbstractEquationODE\nAbstractEquationDAE\nAbstractEquationSDE\nAbstractEquationPODE\nAbstractEquationPDAE\nAbstractEquationPSDE","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Concrete implementations of equation types should be subtypes of one of these types or abstract subtypes thereof.","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Equations have several traits:","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Function Description\nhassolution(::GeometricEquation) \nhasvectorfield(::GeometricEquation) \nhasprimary(::GeometricEquation) \nhassecondary(::GeometricEquation) \nhasinvariants(::GeometricEquation) \nhasparameters(::GeometricEquation) \nhasperiodicity(::GeometricEquation) \nhashamiltonian(::GeometricEquation) \nhaslagrangian(::GeometricEquation) ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Equations should implement some convenience functions for accessing their data:","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"Function Description\nfunctions(::GeometricEquation) \nsolutions(::GeometricEquation) \ninvariants(::GeometricEquation) \nparameters(::GeometricEquation) \nperiodicity(::GeometricEquation) ","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"For each equation type, there should be some methods for functions implemented, that are used to check the validity of initial conditions or the functions provided for the vector fields, etc.:","category":"page"},{"location":"equations/","page":"Equations","title":"Equations","text":"check_initial_conditions(equ::GeometricEquation, ics::NamedTuple) check_parameters(equ::GeometricEquation, params::NamedTuple)","category":"page"},{"location":"equations/#Ordinary-Differential-Equations","page":"Equations","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"ODE\nPODE\nHODE\nIODE\nLODE\nSODE","category":"page"},{"location":"equations/#GeometricEquations.ODE","page":"Equations","title":"GeometricEquations.ODE","text":"ODE: Ordinary Differential Equation\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t)) \n\nwith vector field v.\n\nParameters\n\nvType <: Callable: type of v\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nODE(v, invariants, parameters, periodicity)\nODE(v; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.PODE","page":"Equations","title":"GeometricEquations.PODE","text":"PODE: Partitioned Ordinary Differential Equation\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPODE(v, f, invariants, parameters, periodicity)\nPODE(v, f; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.HODE","page":"Equations","title":"GeometricEquations.HODE","text":"HODE: Hamiltonian Ordinary Differential Equation\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHODE(v, f, hamiltonian, invariants, parameters, periodicity)\nHODE(v, f, hamiltonian; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.IODE","page":"Equations","title":"GeometricEquations.IODE","text":"IODE: Implicit Ordinary Differential Equation\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith force field f, the momentum defined by p. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\ngType <: Callable: type of g\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (tqv) cdot lambda\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIODE(ϑ, f, g, v̄, f̄, invariants, parameters, periodicity)\nIODE(ϑ, f, g; v̄ = _iode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_iode_default_v̄(v, t, q, params) = nothing\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.LODE","page":"Equations","title":"GeometricEquations.LODE","text":"LODE: Lagrangian Ordinary Differential Equation\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\nThis is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nParameters\n\nϑType <: Function: type of ϑ\nfType <: Function: type of f\ngType <: Function: type of g\nωType <: Function: type of ω\nv̄Type <: Function: type of v̄\nf̄Type <: Function: type of f̄\nlagType <: Function: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field\ng: function determining the projection, given by nabla vartheta (q) cdot lambda\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLODE(ϑ, f, g, ω, l, v̄, f̄, invariants, parameters, periodicity)\nLODE(ϑ, f, g, ω, l; v̄ = _lode_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_lode_default_v̄(v, t, q, params) = nothing\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.SODE","page":"Equations","title":"GeometricEquations.SODE","text":"SODE: Split Ordinary Differential Equation\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nParameters\n\nvType <: Union{Tuple,Nothing}: type of v\nqType <: Union{Tuple,Nothing}: type of q\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields for each substep\nq: tuple of functions computing the solutions for each substep\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSODE(v, invariants, parameters, periodicity)\nSODE(v; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\nSODE(v, q, invariants, parameters, periodicity)\nSODE(v, q; invariants=NullInvariants(), parameters=NullParameters(), periodicity=NullPeriodicity())\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"equations/#Differential-Algebraic-Equations","page":"Equations","title":"Differential Algebraic Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"DAE\nPDAE\nHDAE\nIDAE\nLDAE\nSPDAE","category":"page"},{"location":"equations/#GeometricEquations.DAE","page":"Equations","title":"GeometricEquations.DAE","text":"DAE: Differential Algebraic Equation\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))  \n0 = phi (t q(t)) \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) mu(t))  \n0 = phi (t q(t))  \n0 = psi (t q(t) dotq (t)) \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nuType <: Callable: type of u\nϕType <: Callable: type of ϕ\nūType <: OptionalCallable: type of ū\nψType <: OptionalCallable: type of ψ\nv̄Type <: Callable: type of v̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v(v, t, q, params)\nu: function computing the projection u(u, t, q, λ, params)\nϕ: algebraic constraint ϕ(ϕ, t, q, params)\nū: function computing the secondary projection field ū(ū, t, q, λ, params) (optional)\nψ: secondary constraint ψ(ψ, t, q, v, params) (optional)\nv̄: function computing an initial guess for the velocity field v (defaults to v)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nDAE(v, u, ϕ, ū, ψ, v̄, invariants, parameters, periodicity)\nDAE(v, u, ϕ, ū, ψ; kwargs...)\nDAE(v, u, ϕ; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nThe DAE is created by\n\nequ = DAE(v, u, ϕ)\n\nor\n\nequ = DAE(v, u, ϕ, ū, ψ)\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.PDAE","page":"Equations","title":"GeometricEquations.PDAE","text":"PDAE: Partitioned Differential Algebraic Equation\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))  \n0 = phi (t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the vector field v\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nPDAE(v, f, u, g, ϕ, ū, ḡ, ψ; kwargs...)\nPDAE(v, f, u, g, ϕ; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe PDAE is created by\n\nequ = PDAE(v, f, u, g, ϕ)\n\nor\n\nequ = PDAE(v, f, u, g, ϕ, ū, ḡ, ψ)\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.HDAE","page":"Equations","title":"GeometricEquations.HDAE","text":"HDAE: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nhamType <: Callable: Hamiltonian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: function computing the Hamiltonian vector field v\nf: function computing the Hamiltonian vector field f\nu: function computing the projection for q\ng: function computing the primary projection field g\nϕ: primary constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional, defaults to v)\nf̄: function computing an initial guess for the force field f (optional, defaults to f)\nhamiltonian: function computing the Hamiltonian H (usually the total energy of the system)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h, v̄, f̄, invariants, parameters, periodicity)\nHDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h; kwargs...)\nHDAE(v, f, u, g, ϕ, h; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions are defined by\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and μ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g,  ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nThe HDAE is created by\n\nequ = HDAE(v, f, u, g, ϕ, h)\n\nor\n\nequ = HDAE(v, f, u, g, ϕ, ū, ḡ, ψ, h)\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.IDAE","page":"Equations","title":"GeometricEquations.IDAE","text":"IDAE: Implicit Differential Algebraic Equation\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t)) \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nϑ: function determining the momentum\nf: function computing the vector field f\nu: function computing the projection for q\ng: function computing the projection for p\nϕ: algebraic constraints\nū: function computing the secondary projection field baru (optional)\nḡ: function computing the secondary projection field barg (optional)\nψ: secondary constraints (optional)\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, v̄, f̄, invariants, parameters, periodicity)\nIDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nIDAE(ϑ, f, u, g, ϕ; v̄ = _idae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_idae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.LDAE","page":"Equations","title":"GeometricEquations.LDAE","text":"LDAE: Lagrangian Differential Algebraic Equation\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nParameters\n\nϑType <: Callable: type of ϑ\nfType <: Callable: type of f\nuType <: Callable: type of u\ngType <: Callable: type of g\nϕType <: Callable: type of ϕ\nūType <: Callable: type of ū\nḡType <: Callable: type of ḡ\nψType <: Callable: type of ψ\nωType <: Callable: type of ω\nv̄Type <: Callable: type of v̄\nf̄Type <: Callable: type of f̄\nlagType <: Callable: Lagrangian type\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nf: function computing the vector field\nu: function computing the projection for q, for a degenerate system given by lambda\ng: function computing the projection for p, for a degenerate system given by nabla vartheta (q) cdot lambda\nϕ: primary constraints, for a degenerate system given by p - vartheta (tq)\nū: function computing the secondary projection field baru, for a degenerate system given by lambda (optional)\nḡ: function computing the secondary projection field barg, for a degenerate system given by lambda cdot nabla vartheta (tq) (optional)\nψ: secondary constraints, for a degenerate system given by dotp - dotq cdot nabla vartheta (tq) (optional)\nω: function computing the symplectic matrix\nv̄: function computing an initial guess for the velocity field v (optional)\nf̄: function computing an initial guess for the force field f (optional)\nlagrangian: function computing the Lagrangian L\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, v̄, f̄, lagrangian, invariants, parameters, periodicity)\nLDAE(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\nLDAE(ϑ, f, u, g, ϕ, ω, lagrangian; v̄ = _ldae_default_v̄, f̄ = f, invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nwhere \n\n_ldae_default_v̄(v, t, q, params) = nothing\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.SPDAE","page":"Equations","title":"GeometricEquations.SPDAE","text":"SPDAE: Split Partitioned Differential Algebraic Equation EXPERIMENTAL\n\nDefines a split differential algebraic initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v_1(t q(t) p(t)) + v_2(t q(t) p(t) lambda(t)) + v_3(t q(t) p(t) lambda(t) gamma(t))   q(t_0) = q_0  \ndotp (t) = f_1(t q(t) p(t)) + f_2(t q(t) p(t) lambda(t)) + f_3(t q(t) p(t) lambda(t) gamma(t))   p(t_0) = p_0  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v_i and f_i for i = 1  3, primary constraint phi(qp)=0 and secondary constraint psi(qplambda)=0, initial conditions (q_0 p_0), the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d and the algebraic variables (lambda gamma) taking values in mathbbR^n times mathbbR^d.\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nϕType <: Callable: type of ϕ\nψType <: Callable: type of ψ\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv: tuple of functions computing the vector fields v_i, i = 1  3\nf: tuple of functions computing the vector fields f_i, i = 1  3\nϕ: primary constraints\nψ: secondary constraints\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVector, p₀::StateVector, λ₀::StateVector; kwargs...)\nSPDAE(v, f, ϕ, ψ, t₀, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\nSPDAE(v, f, ϕ, ψ, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nKeyword arguments:\n\ninvariants = nothing\nparameters = nothing\nperiodicity = nothing\n\n\n\n\n\n","category":"type"},{"location":"equations/#Stochastic-Differential-Equations","page":"Equations","title":"Stochastic Differential Equations","text":"","category":"section"},{"location":"equations/","page":"Equations","title":"Equations","text":"SDE\nPSDE\nSPSDE","category":"page"},{"location":"equations/#GeometricEquations.SDE","page":"Equations","title":"GeometricEquations.SDE","text":"SDE: Stratonovich Stochastic Differential Equation\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nBType <: Callable: type of B\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the deterministic vector field\nB:  function computing the d x m diffusion matrix\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSDE(v, B, invariants, parameters, periodicity)\nSDE(v, B; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.PSDE","page":"Equations","title":"GeometricEquations.PSDE","text":"PSDE: Stratonovich Partitioned Stochastic Differential Equation\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Callable: type of v\nfType <: Callable: type of f\nBType <: Callable: type of B\nGType <: Callable: type of G\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv:  function computing the drift vector field for the position variable q\nf:  function computing the drift vector field for the momentum variable p\nB:  function computing the d x m diffusion matrix for the position variable q\nG:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nPSDE(v, f, B, G, invariants, parameters, periodicity)\nPSDE(v, f, B, G; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"equations/#GeometricEquations.SPSDE","page":"Equations","title":"GeometricEquations.SPSDE","text":"SPSDE: Stratonovich Split Partitioned Stochastic Differential Equation\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nParameters\n\nvType <: Function: type of v\nf1Type <: Function: type of f1\nf2Type <: Function: type of f2\nBType <: Function: type of B\nG1Type <: Function: type of G1\nG2Type <: Function: type of G2\ninvType <: OptionalInvariants: invariants type\nparType <: OptionalParameters: parameters type\nperType <: OptionalPeriodicity: periodicity type\n\nFields\n\nv :  function computing the drift vector field for the position variable q\nf1:  function computing the drift vector field for the momentum variable p\nf2:  function computing the drift vector field for the momentum variable p\nB :  function computing the d x m diffusion matrix for the position variable q\nG1:  function computing the d x m diffusion matrix for the momentum variable p\nG2:  function computing the d x m diffusion matrix for the momentum variable p\ninvariants: functions for the computation of invariants, either a NamedTuple containing the equation's invariants or NullInvariants\nparameters: type constraints for parameters, either a NamedTuple containing the equation's parameters or NullParameters\nperiodicity: determines the periodicity of the state vector q for cutting periodic solutions, either a AbstractArray or NullPeriodicity\n\nConstructors\n\nSPSDE(v, f1, f2, B, G1, G2, invariants, parameters, periodicity)\nSPSDE(v, f1, f2, B, G1, G2; invariants = NullInvariants(), parameters = NullParameters(), periodicity = NullPeriodicity())\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"problems/","page":"Problems","title":"Problems","text":"CurrentModule = GeometricEquations","category":"page"},{"location":"problems/#Geometric-Equation-Problems","page":"Problems","title":"Geometric Equation Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"EquationProblem","category":"page"},{"location":"problems/#GeometricEquations.EquationProblem","page":"Problems","title":"GeometricEquations.EquationProblem","text":"EquationProblem: stores a GeometricEquation together with initial conditions, parameters, time span and time step size.\n\nParameters\n\nST <: GeometricEquation: super type, used for dispatch\nDT <: Number: data type\nTT <: Real: time step type\nAT <: AbstractArray{DT}: array type of state variable\nequType <: GeometricEquation: equation type\nfunctionsType <: NamedTuple: types of all function methods\nsolutionsType <: NamedTuple: types of all solution methods\nicsType <: NamedTuple: types of all initial conditions \nparType <: OptionalParameters: parameters type\n\nFields\n\nequation: reference to the parent equation object holding the vector fields, etc.\nfunctions: methods for all vector fields, etc., that define the problem\nsolutions: methods for all solutions, etc., if defined\ntspan: time span for problem (t₀,t₁)\ntstep: time step to be used in simulation\nics: NamedTuple containing the initial conditions, must contain one field for each state variable\nparameters: either a NamedTuple containing the equation's parameters or NullParameters indicating that the equation does not have any parameters\n\nSubtypes\n\nThe EquationProblem type has various subtypes for the different equations types, that are defined e.g. via\n\nconst ODEProblem = EquationProblem{ODE}\n\nand provide convenience constructors to construct an equation and the corresponding problem in one step, e.g.,\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)\n\nAll problem subtypes take the following keyword arguments:\n\ninvariants = NullInvariants()\nparameters = NullParameters()\nperiodicity = NullPeriodicity()\n\nIf not set to their corresponding Null types, the user needs to pass a NamedTuple whose values are\n\nfunctions for invariants,\narbitrary data structures for parameters, \nthe same data structure as the solution for periodicity.\n\nThe latter should be zero everywhere, except for those components, that are periodic, i.e., whose value are supposed to stay within a range (0, max). Support for ranges starting with other values than zero is currently missing but can be added if demand arises.\n\n\n\n\n\n","category":"type"},{"location":"problems/#Ordinary-Differential-Equation-Problems","page":"Problems","title":"Ordinary Differential Equation Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"ODEProblem\nPODEProblem\nHODEProblem\nIODEProblem\nLODEProblem\nSODEProblem","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"ODEProblem\nPODEProblem\nHODEProblem\nIODEProblem\nLODEProblem\nSODEProblem","category":"page"},{"location":"problems/#GeometricEquations.ODEProblem","page":"Problems","title":"GeometricEquations.ODEProblem","text":"ODEProblem: Ordinary Differential Equation Problem\n\nOrdinary differential equations define an initial value problem of the form\n\ndotq (t) = v(t q(t)) \n\nwith vector field v.\n\nThe dynamical variables with initial condition q_0 take values in mathbbR^d.\n\nConstructors\n\nODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)\n\nwhere v is the function computing the vector field,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interface of the function v see ODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe function v providing the vector field must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params is a NamedTuple of additional parameters on which the vector field may depend.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.PODEProblem","page":"Problems","title":"GeometricEquations.PODEProblem","text":"PODEProblem: Partitioned Ordinary Differential Equation Problem\n\nA partitioned ordinary differential equation is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d.\n\nConstructors\n\nPODEProblem(v, f, tspan, tstep, ics; kwargs...)\nPODEProblem(v, f, tspan, tstep, q₀::StateVariable, p₀::StateVariable; kwargs...)\n\nwhere v and f are the function computing the vector fields,  tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v and f see PODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and f must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields v and f on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.HODEProblem","page":"Problems","title":"GeometricEquations.HODEProblem","text":"HODEProblem: Hamiltonian Ordinary Differential Equation Problem\n\nA canonical Hamiltonian system of equations is special case of a partitioned ordinary differential equation,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t))  \ndotp (t) = f(t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, given by\n\nbeginaligned\nv =   fracpartial Hpartial p  \nf = - fracpartial Hpartial q \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in T^* Q simeq mathbbR^d times mathbbR^d.\n\nConstructors\n\nHODEProblem(v, f, hamiltonian, tspan, tstep, ics; kwargs...)\nHODEProblem(v, f, hamiltonian, tspan, tstep, q₀::StateVariable, p₀::StateVariable; kwargs...)\n\nwhere v and f are the function computing the vector fields,  hamiltonian returns the value of the Hamiltonian (i.e. the total energy), tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, poisson and hamiltonian see HODE.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f and hamiltonian must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction hamiltonian(t, q, p, params)\n    return ...\nend\n\nwhere t is the current time, q and p are the current solution vectors, v and f are the vectors which hold the result of evaluating the vector fields on t, q and p, and params is a NamedTuple of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.IODEProblem","page":"Problems","title":"GeometricEquations.IODEProblem","text":"IODEProblem: Implicit Ordinary Differential Equation Problem\n\nAn implicit ordinary differential equations is an initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith force field f, the momentum defined by p. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMost integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + λ(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) λ(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variable λ with initial condition λ(t_0) = λ_0 takes values in mathbbR^m.\n\nConstructors\n\nIODEProblem(ϑ, f, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, ics; kwargs...)\nIODEProblem(ϑ, f, g, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe functions ϑ, f and g compute the momentum and the vector fields, respectively.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀ and p₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f and g see IODE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _iode_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. In addition, the functions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, v, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers.\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.LODEProblem","page":"Problems","title":"GeometricEquations.LODEProblem","text":"LODEProblem: Lagrangian Ordinary Differential Equation Problem\n\nA Lagrangian system of equations is a special case of an implicit ordinary differential equations, that is an implicit initial value problem of the form\n\nbeginaligned\ndotq (t) = v(t)  \ndotp (t) = f(t q(t) v(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v  \nf = fracpartial Lpartial q \nendaligned\n\nThis is a special case of an implicit ordinary differential equation, that is defined by a Lagrangian, as well as a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variable v, that is determined such that the constraint p(t) = ϑ(t q(t) v(t)) is satisfied.\n\nMany integrators perform a projection step in order to enforce this constraint. To this end, the system is extended to\n\nbeginaligned\ndotq (t) = v(t) + lambda(t)  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) lambda(t))  \np(t) = ϑ(t q(t) v(t)) \nendaligned\n\nwhere the vector field defining the projection step is usually given as\n\nbeginaligned\ng(t q(t) v(t) λ(t)) = λ(t) cdot nabla ϑ(t q(t) v(t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in T^* Q simeq mathbbR^d times mathbbR^d. The algebraic variable λ with initial condition λ(t_0) = λ_0 takes values in mathbbR^m.\n\nConstructors\n\nLODEProblem(ϑ, f, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, ics; kwargs...)\nLODEProblem(ϑ, f, g, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nwhere ϑ, f and g are the functions computing the momentum and the vector fields, respectively, ω determines the symplectic matrix, and l returns the Lagrangian, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p and λ. The initial conditions q₀, p₀ and λ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}, where λ₀ can also be omitted. For the interfaces of the functions ϑ, f, g, ω and l see LODE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LODEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _lode_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nand\n\nfunction f(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction g(g, t, q, λ)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nand\n\nfunction v̄(v, t, q, p)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nThe function g is used in projection methods that enforce p = ϑ(q). The functions v̄ and f̄ are used for initial guesses in nonlinear implicit solvers. Finally, the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.SODEProblem","page":"Problems","title":"GeometricEquations.SODEProblem","text":"SODEProblem: Split Ordinary Differential Equation Problem\n\nDefines an initial value problem\n\ndotq (t) = v(t q(t))  qquad q(t_0) = q_0 \n\nwith vector field v, initial condition q_0 and the solution q taking values in mathbbR^d. Here, the vector field v is given as a sum of vector fields\n\nv (t) = v_1 (t) +  + v_r (t) \n\nConstructors\n\nSODEProblem(v, q, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, q, tspan, tstep, q₀::StateVariable; kwargs...)\nSODEProblem(v, tspan, tstep, ics::NamedTuple; kwargs...)\nSODEProblem(v, tspan, tstep, q₀::StateVariable; kwargs...)\n\nwhere v is a tuple of functions computing the vector fields for each substep,  q is an optional tuple of functions computing the solution for each substep, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v_i providing the vector field must have the interface\n\nfunction v_i(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nand the functions q_i providing the solutions must have the interface\n\nfunction q_i(q₁, t₁, q₀, t₀, params)\n    q₁[1] = q₀[1] + ...\n    q₁[2] = q₀[2] + ...\n    ...\nend\n\nwhere t₀ is the current time, q₀ is the current solution vector, q₁ is the new solution vector at time t₁, holding the result of computing one substep\n\nThe fact that the function v returns the solution and not just the vector field for each substep increases the flexibility for the use of splitting methods, e.g., it allows to use another integrator for solving substeps. with the vector field v_i.\n\n\n\n\n\n","category":"type"},{"location":"problems/#Differential-Algebraic-Equation-Problems","page":"Problems","title":"Differential Algebraic Equation Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"DAEProblem\nPDAEProblem\nHDAEProblem\nIDAEProblem\nLDAEProblem\nSPDAEProblem","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"DAEProblem\nPDAEProblem\nHDAEProblem\nIDAEProblem\nLDAEProblem\nSPDAEProblem","category":"page"},{"location":"problems/#GeometricEquations.DAEProblem","page":"Problems","title":"GeometricEquations.DAEProblem","text":"DAEProblem: Differential Algebraic Equation Problem\n\nDefines a differential algebraic initial value problem\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t))  \n0 = phi (t q(t)) \nendaligned\n\nwith vector field v, projection u, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t)) + u(t q(t) lambda(t)) + baru (t q(t) dotq (t) dotp (t) mu(t))  \n0 = phi (t q(t))  \n0 = psi (t q(t) dotq (t)) \nendaligned\n\nThe dynamical variable q with initial conditions q(t_0) = q_0 takes values in mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nDAEProblem(v, u, ϕ, tspan, tstep, q₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and u compute the vector field and the projection, respectively, ϕ provides the algebraic constraint. The functions ψ and ū are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, λ and μ. The initial conditions q₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, u, ϕ, ū, ψ see DAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a DAEProblem accepts a function v̄ for the computation of an initial guess for the vector field with default value v̄ = v.\n\nFunction Definitions\n\nThe functions v, u and ϕ must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction u(u, t, q, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q and λ are the current solution vectors, and v, u and ϕ are the vectors which hold the result of evaluating the vector field v, the projection u and the algebraic constraint phi on t, q and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the DAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = DAEProblem(v, u, ϕ, tspan, tstep, q₀, λ₀)\n\nor\n\nprob = DAEProblem(v, u, ϕ, ū, ψ, tspan, tstep, q₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.PDAEProblem","page":"Problems","title":"GeometricEquations.PDAEProblem","text":"PDAEProblem: Partitioned Differential Algebraic Equation Problem\n\nA partitioned differential algebraic equation has the form\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t))  \n0 = phi (t q(t) p(t)) \nendaligned\n\nwith vector fields v and f, projection u and g, algebraic constraint phi=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, ics::NamedTuple; kwargs...)\nPDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and μ. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, u, g, ϕ, ū, ḡ, ψ see PDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a PDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g and ϕ must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nwhere t is the current time, q, p and λ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections u and g, and ϕ holds the algebraic constraint phi, evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the PDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = PDAEProblem(v, f, u, g, ϕ, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = PDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.HDAEProblem","page":"Problems","title":"GeometricEquations.HDAEProblem","text":"HDAEProblem: Hamiltonian Differential Algebraic Equation\n\nA Hamiltonian differential algebraic is an initial value problem, that is a canonical Hamiltonian system of equations subject to Dirac constraints,\n\nbeginaligned\ndotq (t) = v(t q(t) p(t)) + u(t q(t) p(t) lambda(t)) + baru (t q(t) p(t) mu(t))  \ndotp (t) = f(t q(t) p(t)) + g(t q(t) p(t) lambda(t)) + barg (t q(t) p(t) mu(t))  \n0 = phi (t q(t) p(t))  \n0 = psi (t q(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith vector fields v, u, baru and f, g, barg, primary constraint phi(qp)=0 and secondary constraint psi(qpdotqdotp)=0.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable, μ₀::StateVariable = zero(λ₀); kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, ics::NamedTuple; kwargs...)\nHDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable; kwargs...)\n\nThe functions v and f compute the vector field, u and g compute the projections, ϕ provides the algebraic constraint and h the Hamiltonian. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q, p, λ and μ. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions v, f, u, g, ϕ, ū, ḡ, ψ, and h see HDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a HDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = v and f̄ = f.\n\nFunction Definitions\n\nThe functions v, f, u, g, ϕ and h must have the interface\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(g, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction u(u, t, q, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ϕ(ϕ, t, q, p, params)\n    ϕ[1] = ...\nend\n\nfunction h(t, q, p, params)\n    ...\nend\n\nwhere t is the current time, q, p, λ and μ are the current solution vectors, v, f, u and g are the vectors which hold the result of evaluating the vector fields v and f, the projections on the primary constraint u and g,  ϕ holds the algebraic constraint phi, and h returns the Hamiltonian of the system, all evaluated on t, q, p and λ.\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, p, v, f, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the HDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = HDAEProblem(v, f, u, g, ϕ, h, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = HDAEProblem(v, f, u, g, ϕ, ū, ḡ, ψ, h, tspan, tstep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.IDAEProblem","page":"Problems","title":"GeometricEquations.IDAEProblem","text":"IDAEProblem: Implicit Differential Algebraic Equation Problem\n\nAn implicit differential algebraic initial value problem takes the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t)) \nendaligned\n\nwith force field f, the momentum defined by ϑ, projections u and g, algebraic constraint phi(tqvp)=0.\n\nSome integrators also enforce the secondary constraint psi, that is the time derivative of the algebraic constraint phi. In this case, the system of equations is modified as follows\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))   \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq (t) dotp (t)) \nendaligned\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, ics; kwargs...)\nIDAEProblem(ϑ, f, u, g, ϕ, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f, u, g, ϕ, ū, ḡ, ψ see IDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, an IDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _idae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, λ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, λ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.LDAEProblem","page":"Problems","title":"GeometricEquations.LDAEProblem","text":"LDAEProblem: Lagrangian Differential Algebraic Equation Problem\n\nA special case of an implicit initial value problem is a Lagrangian differential algebraic equation of the form\n\nbeginaligned\ndotq (t) = v(t) + u(t q(t) v(t) p(t) lambda(t)) + baru (t q(t) v(t) p(t) mu(t))  \ndotp (t) = f(t q(t) v(t)) + g(t q(t) v(t) p(t) lambda(t)) + barg (t q(t) v(t) p(t) mu(t))  \np(t) = ϑ(t q(t) v(t))  \n0 = phi (t q(t) v(t) p(t))  \n0 = psi (t q(t) v(t) p(t) dotq(t) dotp(t)) \nendaligned\n\nwith momentum p and force field f, given by\n\nbeginaligned\np = fracpartial Lpartial v (qv)  \nf = fracpartial Lpartial q (qv) \nendaligned\n\nprojection fields u, baru and g, barg. This is a special case of a differential algebraic equation with dynamical variables (qp) and algebraic variables v, lambda and mu.\n\nThe dynamical variables (qp) with initial conditions (q(t_0) = q_0 p(t_0) = p_0) take values in mathbbR^d times mathbbR^d. The algebraic variables (λμ) with initial condition (λ(t_0) = λ_0 μ(t_0) = μ_0) take values in mathbbR^m times mathbbR^m.\n\nConstructors\n\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀), μ₀::StateVariable = zero(λ₀); kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, ics; kwargs...)\nLDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀::StateVariable, p₀::StateVariable, λ₀::StateVariable = zero(q₀); kwargs...)\n\nThe function ϑ computes the momentum, f computes the force field, u and g compute the projections, and ϕ provides the algebraic constraint. The functions ψ, ū and ḡ are optional and provide the secondary constraint, that is the time derivative of the algebraic constraint, and the corresponding projection.\n\ntspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entries q and p. The initial conditions q₀, p₀, λ₀ and μ₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}. For the interfaces of the functions ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω and l see LDAE.\n\nIn addition to the standard keyword arguments for EquationProblem subtypes, a LDAEProblem accepts functions v̄ and f̄ for the computation of initial guesses for the vector fields with default values v̄ = _ldae_default_v̄ and f̄ = f.\n\nFunction Definitions\n\nThe functions ϑ and f must have the interface\n\nfunction ϑ(p, t, q, v, params)\n    p[1] = ...\n    p[2] = ...\n    ...\nend\n\nfunction f(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the current velocity and f and p are the vectors which hold the result of evaluating the functions f and ϑ on t, q and v. The funtions g, v̄ and f̄ are specified by\n\nfunction u(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction g(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction v̄(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f̄(f, t, q, v, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nand the functions ω and l, computing the symplectic matrix and the Lagrangian, have the following signature\n\nfunction ω(f, t, q, v, params)\n    ω[1,1] = ...\n    ω[1,2] = ...\n    ...\nend\n\nfunction l(t, q, v, params)\n    return ...\nend\n\nSome integrators also enforce the secondary constraint psi and require the following additional functions\n\nfunction ū(u, t, q, v, p, μ, params)\n    u[1] = ...\n    u[2] = ...\n    ...\nend\n\nfunction ḡ(g, t, q, v, p, μ, params)\n    g[1] = ...\n    g[2] = ...\n    ...\nend\n\nfunction ψ(ψ, t, q, v, p, q̇, ṗ, params)\n    ψ[1] = ...\nend\n\nWith the above function definitions the LDAEProblem can be created by\n\ntspan = (0.0, 1.0)\ntstep = 0.1\nq₀ = [1., 1.]\np₀ = [1., 0.]\nλ₀ = [0.]\nμ₀ = [0.]\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ω, l, tspan, tstep, q₀, p₀, λ₀)\n\nor\n\nprob = LDAEProblem(ϑ, f, u, g, ϕ, ū, ḡ, ψ, ω, l, tspan, tstep, q₀, p₀, λ₀, μ₀)\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.SPDAEProblem","page":"Problems","title":"GeometricEquations.SPDAEProblem","text":"\n\n\n\n","category":"type"},{"location":"problems/#Stochastic-Differential-Equation-Problems","page":"Problems","title":"Stochastic Differential Equation Problems","text":"","category":"section"},{"location":"problems/","page":"Problems","title":"Problems","text":"SDEProblem\nPSDEProblem\nSPSDEProblem","category":"page"},{"location":"problems/","page":"Problems","title":"Problems","text":"SDEProblem\nPSDEProblem\nSPSDEProblem","category":"page"},{"location":"problems/#GeometricEquations.SDEProblem","page":"Problems","title":"GeometricEquations.SDEProblem","text":"SDEProblem: Stratonovich Stochastic Differential Equation Problem\n\nDefines a stochastic differential initial value problem\n\nbeginaligned\ndq (t) = v(t q(t))  dt + B(t q(t)) circ dW   q(t_0) = q_0 \nendaligned\n\nwith drift vector field v, diffusion matrix B, initial conditions q_0, the dynamical variable q taking values in mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSDEProblem(v, B, tspan, tstep, ics::NamedTuple; kwargs...)\nSDEProblem(v, B, tspan, tstep, q₀::StateVariable; kwargs...)\n\nwhere v is the function computing the vector field and B computes the diffusion matrix tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v and B, providing the drift vector field and diffusion matrix. The function v must have the interface\n\nfunction v(v, t, q, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nwhere t is the current time, q is the current solution vector, v is the vector which holds the result of evaluating the vector field v on t and q, and params are additional parameters. The function B should have a method with interface\n\nfunction B(B, t, q, params)\n    B[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.PSDEProblem","page":"Problems","title":"GeometricEquations.PSDEProblem","text":"PSDEProblem: Stratonovich Partitioned Stochastic Differential Equation Problem\n\nA partitioned stochastic differential equations is an initial value problem of the form\n\nbeginaligned\ndq (t) = v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) = f(t q(t) p(t))  dt + G(t q(t) p(t)) circ dW   p(t_0) = p_0\nendaligned\n\nwith the drift vector fields v and f, diffusion matrices B and G, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nPSDEProblem(v, f, B, G, tspan, tstep, ics::NamedTuple; kwargs...)\nPSDEProblem(v, f, B, G, tspan, tstep, q₀::StateVariable; p₀::StateVariable; kwargs...)\n\nwhere v and f are the functions computing the vector field and B and G compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f, B and G, providing the drift vector fields and diffusion matrices, each take five arguments, v(v, t, q, p, params), f(f, t, q, p, params), B(B, t, q, p, params) and G(G, t, q, p, params), where t is the current time, (q, p) is the current solution, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B, G on t and (q,p), and params are optional parameters.\n\nThe corresponding methods should have the following signatures:\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\n\n\n\n\n","category":"type"},{"location":"problems/#GeometricEquations.SPSDEProblem","page":"Problems","title":"GeometricEquations.SPSDEProblem","text":"SPSDEProblem: Stratonovich Split Partitioned Stochastic Differential Equation Problem\n\nDefines a partitioned stochastic differential initial value problem\n\nbeginaligned\ndq (t) =   v(t q(t) p(t))  dt + B(t q(t) p(t)) circ dW   q(t_0) = q_0  \ndp (t) =  f_1(t q(t) p(t)) + f_2(t q(t) p(t))   dt +  G_1(t q(t) p(t)) + G_2(t q(t) p(t))  circ dW   p(t_0) = p_0 \nendaligned\n\nwith the drift vector fields v and f_i, diffusion matrices B and G_i, initial conditions q_0 and p_0, the dynamical variables (qp) taking values in mathbbR^d times mathbbR^d, and the m-dimensional Wiener process W\n\nConstructors\n\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, ics::NamedTuple; kwargs...)\nSPSDEProblem(v, f1, f2, B, G1, G2, tspan, tstep, q₀::StateVariable; p₀::StateVariable; kwargs...)\n\nwhere v and f are the functions computing the vector field and Bᵢ and Gᵢ compute the diffusion matrices, tspan is the time interval (t₀,t₁) for the problem to be solved in, tstep is the time step to be used in the simulation, and ics is a NamedTuple with entry q. The initial condition q₀ can also be prescribed directly, with StateVariable an AbstractArray{<:Number}.\n\nFor possible keyword arguments see the documentation on EquationProblem subtypes.\n\nFunction Definitions\n\nThe functions v, f1, f2, B, G1 and G2, providing the drift vector fields and diffusion matrices, all take five arguments, (out, t, q, p, params).\n\nfunction v(v, t, q, p, params)\n    v[1] = ...\n    v[2] = ...\n    ...\nend\n\nfunction f1(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction f2(f, t, q, p, params)\n    f[1] = ...\n    f[2] = ...\n    ...\nend\n\nfunction B(B, t, q, p, params)\n    B[1,1] = ...\n    ...\nend\n\nfunction G1(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nfunction G2(G, t, q, p, params)\n    G[1,1] = ...\n    ...\nend\n\nwhere t is the current time, (q,p) is the current solution vector, and v, f, B and G are the variables which hold the result of evaluating the vector fields v, f and the matrices B_i, G_i on (t,q,p).\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"Index","title":"Index","text":"CurrentModule = GeometricEquations","category":"page"},{"location":"reference/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GeometricEquations","category":"page"},{"location":"#GeometricEquations","page":"Home","title":"GeometricEquations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GeometricEquations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In GeometricEquations.jl we define three basic types of equations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ordinary differential equations (ODEs),\ndifferential algebraic equations (DAEs),\nstochastic differential equations (SDEs).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For each type, there are several subtypes","category":"page"},{"location":"","page":"Home","title":"Home","text":"standard equations (ODE, DAE, SDE),\nimplicit equations (IODE, IDAE),\npartitioned equations (PODE, PDAE, PSDE),\nHamiltonian equations (HODE, HDAE),\nLagrangian equations (LODE, LDAE),\nsplit equations (SODE, SPDAE, SPSDE).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each equation holds a number of functions determining the vector field, constraints, and possibly additional information like periodicity, invariants and the Hamiltonian or Lagrangian. In addition to each equation type, GeometricEquations.jl implements a corresponding problem type. Each problem holds an equation, a time span (t₀,t₁) to integrate over, a time step to be used in the simulation, initial conditions and optionally parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The EquationProblem type holds an equation together with initial conditions and parameters, the time span and the time step of a simulation.\nThe EnsembleProblem type holds an equation together with several initial conditions and/or parameters, etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GeometricEquations used to be part of GeometricIntegrators and is primarily used to define equations and problems for GeometricIntegrators. GeometricProblems contains various predefined problems and EulerLagrange can be used to generate code for equations from action principles.","category":"page"}]
}
